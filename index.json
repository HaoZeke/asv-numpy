{"project": "numpy", "project_url": "http://numpy.org/", "show_commit_url": "https://github.com/numpy/numpy/commit/", "hash_length": 8, "revision_to_hash": {"42": "e8c50dc6676e380e814c77927445ab3594382bc4", "740": "d8e22e7e6479aa38b62c53f14ebaf98328131061", "760": "3cb02b56a10d3fe8cf6a7ae7b36e9a2f52661c2e", "871": "957cf7970b0d2b2c600ae6459fb45db8ef498de1", "1215": "ac4db180f8cab1d302e699426a7257ec6b0df426", "1435": "5ac24f59ed0053f58781d198e64e6ebe6dbe1d69", "1441": "513d80a5a37a3f6e7bb31e4fc4437fd229d8906c", "1591": "2efca402e8c6aae80ec131fa350c04e5463c8692", "1767": "cbec6098bf702e19d2923d15d420e9410d94bf5c", "1916": "c79bcec14a12a38a1563d1189324257e5df71397", "2054": "3a01f1da914f586ade80cad147d6ea6781d08265", "2167": "d99b776ffb2a6d5718bfdb7f17b46c06a3dc84fc", "2472": "9da998fd005e4d4774cd7f0152490a5bf8c35c99", "2788": "6dd69530d58ba65f4a37167ddec7c9cf19e44c18", "2916": "87596eef24789199f98b502559f110cecdd05025", "2949": "cc6bed52164cf955d56081835e1790622220ca62", "2986": "64be3e2a89c72a8b23ad11b3719bd66725658c61", "3015": "c90202ce60184a803b311754b26f1386bcf1757f", "3096": "56ac5f7711cc399db40738a625d2f33f24fb6166", "3192": "f25e1581827ee3ec98518fe3ad7b855904202383", "3259": "c9d632d3d112854a7a865762097dedc6535a41ed", "3290": "3301a33d6b8daa647ff744b1e6302705de5d67ba", "3366": "1a6b656657baa12f6e3ab41ebb731e2a162f262c", "3543": "9d647f6a0b2f1583ac4e1f9542523ac9db565d45", "3724": "2be238df5e6682083c448264e52d2d8df0055e9c", "3846": "8410a4199e0efea7f56ed474c9754cf4895695b2", "3983": "cd8db12913c9bd7323b77a03a8fa11667634b1a9", "4589": "d83d143053c28864fd9762b8892cb78f7b58f927", "4635": "e43987ae07a1e3ba4b1fb63273069028e4e3d2ce", "4881": "b38e5c2a3b7841aad8df6af35c8e49400ad5b5d9", "4904": "54bb7abd3adc59578c559acb2d2938ae42b401a1", "4948": "6727624e1c42177c0a60a1baf9e46c41ccbdcf20", "4998": "ff040d986da26c846c3b865afa99e0f6ced82b7a", "5005": "68072bf7d9c57895ebe51cfca2aaac52506faec2", "5090": "c29e590ee6bdde6168216642285828fa140c0205", "5144": "ad3f9e63e0598351c51bed7c4686300527f2488d", "5203": "f5596a9d809fbba266aad1702fd048f1de32d1f0", "5277": "d4f826b4bafeea0e4a16b2cb3954b2155483e91a", "5964": "480b20bb72547d35f91a79c2c1bc6166316a56d3", "6082": "efc49bb76f9d9eacb3825d6f42ba283e0c0985c2", "6105": "2f9063f598515a2708decd55a13cd5672851047f", "6111": "c3e0147d49286c0cb1b65a95d42f5eb4a4779129", "7077": "94a1fa8166f715024c3ace71ef25b8498d0c8661", "7287": "76b40e882632f60ecc600770c8eee8d4594754b8", "7290": "4b42c8f6b81d87f35ed8dcf4430224992cf2d296", "7596": "c7ba5001b484eb7565f3a4b1fecadb81f74884bd", "7601": "2edbff0a555835435e19e22fd3e80a522b2beb70", "7605": "05cc071eb092c3953d26dfd53831f9828596cf6c", "7607": "351726ab14cf919aab55fb91608f6448bb063609", "7838": "1ddfa53167695671adbd72de056ae9d30f5c20f7", "7900": "9673b8f82442d84bcdc22690d44ab4d30dabcc81", "7919": "d68b2318454e777a3ae41df019bbed86fdf00f4a", "7924": "c069eee07f2a976b3c2660670dc7bca6438ee94f", "8049": "97cb28e72124ff621958127fde68e1327ac2e324", "8077": "33047912898fb4e15045e8940b0988fb1e474de2", "8094": "de969d7f94ddfc1854565518d5da61fbfc8bf4a3", "8515": "cd6c14be42c149730349ba551d8083f3c08b9c73", "8649": "9b2031f636545bf8e91e59770eb284f56d2a04fd", "8733": "65bcb41240e260e5f8c85e4e30a8f6bc68c72567", "8748": "ceba67b52a8c9ad7ce36553add4506d84a70ad30", "8759": "1e85f6fd045dd75a0697bed5bb619fb792632da2", "8765": "039ceba764704d0b4182cd2ecd6b88242f792804", "8847": "b11e3af9487cf3342bbad742231c312a02398f91", "8956": "9b46e7b7c47cb676999014cbb93709a12e7d63e3", "9026": "41fa279b579c68ac5f5991800034ba94c7ca8b50", "9071": "68538b74483009c2c2d1644ef00397014f95a696", "9830": "09bb26867d73173d74b4f9d4d481064e6044fa71", "9876": "ca07bce202ae26b6f0a73870eb2ef0b88e0210c5", "9952": "651ef74c4ebe7d24e727fd444b1985117ef16fae", "10100": "50366a2ac0d6158e4434ec5e5b4a9a521610628b", "10201": "f2175177b060d01ec5bf6f7e038d71563995fb42", "10586": "1cd02e093d4a27ff526dfffa2152a67e93817fbd", "10683": "e0e3a8732859639917be89f525bd359cf8d608d7", "10713": "a43307cdcc06a358097a9e88de388409a5b99735", "10714": "0c5a166183764aeb3fd1fba799caea489f20682f", "10894": "21bda0e23c6d2e02776e00268bcfee71740f3580", "10952": "697316a867a32e9f72778a29226c9febbf867ee8", "11907": "1bcc80257c94427436eea2e50c70c78179ed1fb9", "11963": "4777d09b39ac0a331e1ac9578e3a754c0e084574", "12166": "260e8f26f8f808e473f1c839411e28bd33edae4e", "12280": "0ccaab00ba14eebeb6620e6c64723189e2bd0a11", "12411": "a60b3901cd635d28bef8328e83bafd35ce631e08", "12438": "3bf8706cefd28d33fb3ea1915d8a11f54ee7cfef", "12590": "4322701029c8bf1d87203cafe781a0128dd86a62", "13048": "23f8dcf86cf692fcc9dce48350d5d86c0bc63ada", "13148": "48c77a64aba109de54d90f103203f1990325c37c", "13266": "62a7575fd82ddf028517780c01fecf7e0cca27aa", "13574": "96b4349da97fd49fb04b678ce16897101677b09f", "13746": "faa6fa074c966cf30b68b2244bb55691edb1bba1", "13794": "c7ad14f5f3069e93a674e0ddf260d7da6c71a5a7", "13799": "4563730a2d036307f1b67b2856d749aabdd8d546", "13857": "36d947fe379e7534624328f7382e4e1175823170", "13918": "07601a64cdfeb1c0247bde1294ad6380413cab66", "14134": "c88fd91482782f35a78d6144331471085b8695b0", "14153": "d44b9c61499f8bc5a9fc94286cd52f05e15e003f", "14443": "c04513ca87f3471c407d00fa3be9d456cc34a1a3", "14555": "762c6f15bf57506e21239a4dd68192e4da6014f7", "15167": "b9640613ddeaa5993916718ebec8c71d4001d489", "15308": "edb902cdc6573553afcf11047ecdfb447e444322", "15380": "2c24d62c775dac583235606a396b4966a3f1144c", "15429": "183fdb290cd46b1f01303d24ac0c9fc3ff24fe05", "15442": "e905cad9646ad65316458bbc7f5c83a9d5ec8728", "15495": "f769c64026f5ff993ec1e28cbd9f39b8da75347d", "15747": "90d1f8fb7e43a1c6664d6a1a05d01d9fafbfc7ea", "15860": "c16af049301ed0a88c57e403854f90725a4a8a7d", "15898": "5667fbafb5d84e3a412a07aac72c769baa590579", "16072": "ea8aa221f98d0bbd24884e9d6e31fbb613f478f1", "16076": "e46c2d78a27f25e66624a818276be57ef9458e60", "16292": "2d1d5c4535bd6df34bed4bf304e253667abf8096", "16308": "66e91fdef4755075689f63e55732d512deb955f2", "16415": "fe0231d5e5256696c9aa923e62e0ca1d02223b40", "16528": "f2756423f00b03063c9424f014ee814ae2ac2884", "16649": "199dc1a43a37adbc0d92f58574494ed80a1fed25", "16687": "4092a9e160cc247a4a45724579a0c829733688ca", "16881": "abcb51151634c09b0db4eb462939f910555b7971", "16985": "ccc6b8d8fcf92cc6dc19f7e14d91fc6c127114a6", "17223": "fe3e46d2876af2546a5fcc752ead8aa736ea2658", "17276": "bb6e3dc30016b89bf154f7d7fce4248e760bd40f", "17442": "67551112fa684d1686ed173eb9724a4b8a7a86fa", "17559": "bfc9a059c48c57c4ef20bebe88d6f6ce363d1464", "17583": "4cf6f18cff3a4080c6a53e5c2bd63e6b9bf7e5db", "17616": "75d28bb59899eedcb83bd8e38be708a9cc5958e7", "17657": "561f1accf861ad8606ea2dd723d2be2b09a2dffa", "17963": "61e667e4a6b6e55356dc97d2f66eb7afb4a69b55", "17999": "11f77c8b19dae99981910695a806cbf4def67e24", "18416": "d6ab6da640156e4a75a78d5d6e7f25a098b5f52b", "18468": "59aec750c677b348dce102bc6fa1e6f9395362b8", "18529": "e94ed84010c60961f82860d146681d3fd607de4e", "18680": "1462df1c20eae44d28e6b665b5d194788f57efc5", "19123": "cde88ddf408f41ca2669adc4401fb69682726a55", "19142": "31465473c491829d636c9104c390062cba005681", "19604": "d64539a97a7d21857b71e181f848a17d15a48ef7", "19766": "6914bb41f0fb3c1ba500bae4e7d671da9536786f", "20042": "7dcee7a469ad1bbfef1cd8980dc18bf5869c5391", "20126": "6a58e25703cbecb6786faa09a04ae2ec8221348b", "20435": "73299826729be58cec179b52c656adfcaefada93", "20710": "83419d6462461110035fa27e322efed557c739ac", "20777": "d3348c1123d3862a42d50a7fee14e50b268944a4", "20876": "7850096157436c650803e8ea6d98ec0d42d96102", "21025": "ccc68b80305ff5b363d10f6e905fb4e5276a8adb", "21087": "ccfbcc1cd9a4035a467f2e982a565ab27de25b6b", "21301": "5adb81051086a45fe3b59ba506b567340ec9bd5e", "21555": "b261d8e562d162397fb0458cf8f281e0bb8e4ced", "21564": "8706d48bd9918fca93ee50cb8bdc04d8ed16cbbd", "21852": "f82c2b62d18b381baefc30f8e8d7788d08a0bd16", "21951": "de28edd8f514b82c0524b55f622078d47f479322", "22287": "c9424106d678a05a0520e74d529a448241223f32", "22366": "0cf81b01c87383ac19e145d312a10efa73e92715", "22436": "971e2e89d08deeae0139d3011d15646fdac13c92", "22608": "685b9ace06f1dc50e2698099d7a2b6a241379318", "22727": "0eeb158ead494e130a25239ac8473a06451b1072", "23110": "08b17aee272fb3f64bb0e5e96e0376c0f9fd9424", "23538": "7ebbc2ed3b4a388dd3942e1d8ef2de18074a09b3", "23799": "9bd91ae86d2c5abccb031846d05199bbc831a342", "23987": "eb5dda56f2a5a845ad1121914d461f22a815fcaa", "24160": "d9b1e32cb8ef90d6b4a47853241db2a28146a57d", "24433": "29759461091f9a4a40ff2f4ae2126e0a5af1fcdd", "24465": "cbdc3b7477aa0b497406bbb2df1025bed290f3cb", "24549": "fce34f559f17674e7a3301c46b0a9cc991c143d4", "24911": "ff3df08438d570b0ccdda3f8a008278d8a4ad394", "25109": "346f5b61e5a0da82f46760a66101589e7b776426", "25289": "e1c290003bd7ee9940eb9b400dda64453228aa96", "25381": "2410c6d0a63cb56455fc9ab6affcf1a776c82134", "25425": "3dec7099ce38cb189880f6f69df318f35ff9a5ea", "25436": "648fe68f79dfbad21947db4b55873703db0675c4", "25522": "91118b3363b636f932f7ff6748d8259e9eb2c23a", "26045": "df256d0d2f3bc6833699529824781c58f9c6e697", "26261": "b07baa1e0ee0a4ca5dfd89bf51a0f57340b639b8", "26366": "94721320b1e13fd60046dc8bd0d343c54c2dd2e9", "26517": "0ea1a6e4f7904b79d26239804c1712a389f46a6b", "26737": "c063b7dc2a4d96a1ebc6c9c0373eae9f722bf69a", "26756": "32f514f546733ae1960077d2be93be970f4e13ef", "26965": "92ebe1e9a6aeb47a881a1226b08218175776f9ea", "27319": "13661ac7002a6b39072e616c19ff43daaec60f7e", "27788": "68752f786df542d340f25c41a8920d9b2aed66cf", "28368": "5010177cfcab1efff8cf5b8eeee093491ae4bc8b", "28400": "6d7b8aaed5ae9f0435764675ebac8c9ada06738f", "28643": "a37b3a82f1abc3e73287883acfd2b06f88a09f13", "28712": "03ec0bc0e7a631e6d7339eae3399602a59e2738c", "28989": "21e48ca557d476feb2654a6c25551ee0412be3c4", "29054": "8f4b73a0d04f7bebb06a154b43e5ef5b5980052f", "29309": "fb215c76967739268de71aa4bda55dd1b062bc2e", "29464": "d7aa4085623b222058edb0ff38392c38c5e00c54", "29995": "b19ad5bfa396a4600a52a598a30a65d4e993f831", "30443": "27b98cbe0dd9d2969e9c227e7a2070aa56f41d6d", "30637": "7aeb763c0cb7b2ada635e9e97b7b3b416f994a8c", "30659": "5cbc5802f9835dd073d8a3a1d4fd34ddfb6b73e8", "30843": "e40a0b2f152eb98f9ee75f7091f64e3998349492", "31014": "b235f9e701e14ed6f6f6dcba885f7986a833743f", "31377": "df6d2600c51502e1877aac563658d0616a75c5e5", "31663": "2fe48d2d98a85c8ea3f3d5caffd952ea69e99335", "32305": "d4d0584ccb508cad69288b504e6c8b04aa0d5caf", "32553": "c0b003e9c787ccab27f6fe57c154d7b881da5795", "32698": "640fff6b33eb092319160b300b80bbbe3669cd35", "32782": "150c1233a717240998567d1cc58911701224ceb6", "32963": "0bbe78772c50db4fe3d1c5b8dbec439dc45c00ba", "33084": "950f507d4c981a6a3292029936ac0277ab05840f", "33091": "c3d0a09342c08c466984654bc4738af595fba896", "33175": "4adc87dff15a247e417d50f10cc4def8e1c17a03", "33336": "7ce4118531b585b5d8f0380c6b896ae22d93bd96", "33643": "f6dddcb2e5ea5ed39675f14429af3585c585a666", "33867": "7d4349e332fcba2bc3f266267421531b3ec5d3e6", "34037": "ef0ec786fd4c7622ad2fa0e54d3881f3b9bbd792", "34278": "08772f91455db66810995db5e9d0671f91e027ed", "34320": "08e6510daf37e0317ab72f3ab48464ba522f96a6", "34392": "5726e6cec0dd2fd1d28c6258c89004887dc0f61a", "34431": "6377d884d1e9bc2cbb8b0c4155521832a39bcfed", "34604": "5c598ed6c78870a9d7c092f716c819ef48e5b8f4", "34793": "54c52f13713f3d21795926ca4dbb27e16fada171", "34954": "1f82da745496092d85b402b1703877462a7c2de2", "35133": "21cacafbeeff812cf49ca0102d1dd582b6d77e2b", "35273": "e47cbb69bebf36007c3ea009aee03e4bfe3b3f3d", "35477": "f8021557bb402c514d8be5a9f005c1565fd57eb8", "35790": "de82cd9468704a033702974010ee7e7efc85b393", "35819": "b05ee6e7d062e6a9ec8b350f8e6e554a241d6b65", "35844": "4f0a3eb82ed9d06ce0f0a25120b1d433b4f64de5", "35980": "754e59d549455e81f5d4923ec2ac8d63f034bd14", "36101": "8cec82012694571156e8d7696307c848a7603b4e"}, "revision_to_date": {"42": 1010250430000, "740": 1080942012000, "760": 1081968728000, "871": 1097349846000, "1215": 1129103142000, "1435": 1131769706000, "1441": 1131851529000, "1591": 1134458827000, "1767": 1136491532000, "1916": 1137917799000, "2054": 1140130368000, "2167": 1142327266000, "2472": 1148854131000, "2788": 1153471716000, "2916": 1155540872000, "2949": 1156194384000, "2986": 1156794775000, "3015": 1157428144000, "3096": 1158779673000, "3192": 1160425354000, "3259": 1161233179000, "3290": 1161767157000, "3366": 1165042730000, "3543": 1175637762000, "3724": 1180631535000, "3846": 1187462962000, "3983": 1194559578000, "4589": 1211082979000, "4635": 1211787689000, "4881": 1216657071000, "4904": 1216831681000, "4948": 1217537675000, "4998": 1218608267000, "5005": 1218666290000, "5090": 1220400184000, "5144": 1221033369000, "5203": 1222317976000, "5277": 1225192990000, "5964": 1237357434000, "6082": 1238247937000, "6105": 1238767315000, "6111": 1238907901000, "7077": 1259629925000, "7287": 1261409435000, "7290": 1261963508000, "7596": 1271580439000, "7601": 1271583582000, "7605": 1271594530000, "7607": 1271932516000, "7838": 1280662582000, "7900": 1282045592000, "7919": 1282740471000, "7924": 1283257801000, "8049": 1287297181000, "8077": 1289224772000, "8094": 1290078864000, "8515": 1300868697000, "8649": 1301858926000, "8733": 1303929670000, "8748": 1304439777000, "8759": 1304793730000, "8765": 1305358911000, "8847": 1307957944000, "8956": 1309549599000, "9026": 1310325134000, "9071": 1311186558000, "9830": 1336165331000, "9876": 1337434901000, "9952": 1340207109000, "10100": 1345509889000, "10201": 1348118703000, "10586": 1356729952000, "10683": 1358806942000, "10713": 1360182042000, "10714": 1360443096000, "10894": 1364150879000, "10952": 1365311159000, "11907": 1378050610000, "11963": 1378665363000, "12166": 1380482446000, "12280": 1381686735000, "12411": 1383002462000, "12438": 1383485948000, "12590": 1388487707000, "13048": 1393769459000, "13148": 1394750047000, "13266": 1395783838000, "13574": 1402237862000, "13746": 1406747979000, "13794": 1407263229000, "13799": 1407580724000, "13857": 1409154091000, "13918": 1410080234000, "14134": 1414340499000, "14153": 1414930922000, "14443": 1422808828000, "14555": 1425216987000, "15167": 1439313035000, "15308": 1442856145000, "15380": 1443496521000, "15429": 1444097817000, "15442": 1444246477000, "15495": 1444660531000, "15747": 1447359318000, "15860": 1449535709000, "15898": 1450120843000, "16072": 1452119720000, "16076": 1452133260000, "16292": 1453770183000, "16308": 1454010965000, "16415": 1455061855000, "16528": 1456185152000, "16649": 1458424675000, "16687": 1459109632000, "16881": 1464312772000, "16985": 1466868751000, "17223": 1473642948000, "17276": 1475538767000, "17442": 1479339043000, "17559": 1482099063000, "17583": 1482185626000, "17616": 1483298534000, "17657": 1484509772000, "17963": 1488844343000, "17999": 1489850965000, "18416": 1494454540000, "18468": 1495130479000, "18529": 1496849195000, "18680": 1499381877000, "19123": 1506523104000, "19142": 1506715810000, "19604": 1513126148000, "19766": 1515268836000, "20042": 1519161772000, "20126": 1520870266000, "20435": 1524857809000, "20710": 1528296187000, "20777": 1528825313000, "20876": 1529537186000, "21025": 1531154140000, "21087": 1532350593000, "21301": 1534866571000, "21555": 1537663658000, "21564": 1537712698000, "21852": 1540157357000, "21951": 1541288187000, "22287": 1545254129000, "22366": 1546640909000, "22436": 1547420295000, "22608": 1548968040000, "22727": 1551199362000, "23110": 1555880064000, "23538": 1558987643000, "23799": 1561921238000, "23987": 1563234580000, "24160": 1564157414000, "24433": 1566664735000, "24465": 1566940237000, "24549": 1567805205000, "24911": 1571167831000, "25109": 1573423148000, "25289": 1575582767000, "25381": 1576983312000, "25425": 1577645001000, "25436": 1577847206000, "25522": 1578332821000, "26045": 1583805203000, "26261": 1587316043000, "26366": 1588463410000, "26517": 1589811515000, "26737": 1590962166000, "26756": 1591145547000, "26965": 1592677046000, "27319": 1595354235000, "27788": 1599697005000, "28368": 1603920425000, "28400": 1604079888000, "28643": 1606488936000, "28712": 1607010228000, "28989": 1608857990000, "29054": 1609818082000, "29309": 1612030209000, "29464": 1612723392000, "29995": 1616870751000, "30443": 1620517773000, "30637": 1621725882000, "30659": 1621814121000, "30843": 1623161796000, "31014": 1624128655000, "31377": 1626629681000, "31663": 1629051347000, "32305": 1634690747000, "32553": 1636059963000, "32698": 1637099964000, "32782": 1637678015000, "32963": 1639089796000, "33084": 1639798050000, "33091": 1639946294000, "33175": 1640900255000, "33336": 1642115464000, "33643": 1643923442000, "33867": 1646681274000, "34037": 1649720590000, "34278": 1653065826000, "34320": 1653332058000, "34392": 1653598038000, "34431": 1653922998000, "34604": 1654900835000, "34793": 1655927847000, "34954": 1657319478000, "35133": 1660413749000, "35273": 1662728873000, "35477": 1665525712000, "35790": 1668893166000, "35819": 1669128169000, "35844": 1669251424000, "35980": 1670102798000, "36101": 1671331494000}, "params": {"arch": ["x86_64"], "cpu": ["11th Gen Intel(R) Core(TM) i9-11900K @ 3.50GHz"], "machine": ["rurgi9home"], "num_cpu": ["16"], "os": ["Linux 6.1.1-arch1-1"], "ram": ["65592908"], "python": ["3.9"], "branch": ["main"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "11th Gen Intel(R) Core(TM) i9-11900K @ 3.50GHz", "machine": "rurgi9home", "num_cpu": "16", "os": "Linux 6.1.1-arch1-1", "ram": "65592908", "python": "3.9", "branch": "main"}], "benchmarks": {"bench_app.LaplaceInplace.time_it": {"code": "class LaplaceInplace:\n    def time_it(self, update):\n        self.run()\n\n    def setup(self, update):\n        N = 150\n        Niter = 1000\n        dx = 0.1\n        dy = 0.1\n        dx2 = (dx * dx)\n        dy2 = (dy * dy)\n    \n        def num_update(u, dx2, dy2):\n            u[1:(-1), 1:(-1)] = ((((u[2:, 1:(-1)] + u[:(-2), 1:(-1)]) * dy2) +\n                                  ((u[1:(-1), 2:] + u[1:(-1), :(-2)]) * dx2))\n                                 / (2 * (dx2 + dy2)))\n    \n        def num_inplace(u, dx2, dy2):\n            tmp = u[:(-2), 1:(-1)].copy()\n            np.add(tmp, u[2:, 1:(-1)], out=tmp)\n            np.multiply(tmp, dy2, out=tmp)\n            tmp2 = u[1:(-1), 2:].copy()\n            np.add(tmp2, u[1:(-1), :(-2)], out=tmp2)\n            np.multiply(tmp2, dx2, out=tmp2)\n            np.add(tmp, tmp2, out=tmp)\n            np.multiply(tmp, (1.0 / (2.0 * (dx2 + dy2))),\n                        out=u[1:(-1), 1:(-1)])\n    \n        def laplace(N, Niter=100, func=num_update, args=()):\n            u = np.zeros([N, N], order='C')\n            u[0] = 1\n            for i in range(Niter):\n                func(u, *args)\n            return u\n    \n        func = {'inplace': num_inplace, 'normal': num_update}[update]\n    \n        def run():\n            laplace(N, Niter, func, args=(dx2, dy2))\n    \n        self.run = run", "min_run_count": 2, "name": "bench_app.LaplaceInplace.time_it", "number": 0, "param_names": ["update"], "params": [["'inplace'", "'normal'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e912d48a31445b41d3721a0504b60aa72ddb03e4689b8386bdca5446901fa5ba", "warmup_time": -1}, "bench_app.MaxesOfDots.time_it": {"code": "class MaxesOfDots:\n    def time_it(self):\n        self.maxes_of_dots(self.arrays)\n\n    def setup(self):\n        np.random.seed(1)\n        nsubj = 5\n        nfeat = 100\n        ntime = 200\n    \n        self.arrays = [np.random.normal(size=(ntime, nfeat))\n                       for i in range(nsubj)]", "min_run_count": 2, "name": "bench_app.MaxesOfDots.time_it", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c35d6b0cbd7e439f6dc9f9844f9a6aac5e1702e666595106714a3ffb372b6be0", "warmup_time": -1}, "bench_array_coercion.ArrayCoercionSmall.time_array": {"code": "class ArrayCoercionSmall:\n    def time_array(self, array_like):\n        np.array(array_like)", "min_run_count": 2, "name": "bench_array_coercion.ArrayCoercionSmall.time_array", "number": 0, "param_names": ["array_like"], "params": [["range(0, 3)", "[1]", "1", "array([5])", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "02bfee29f8ec04abfab771e56eca7f16ee6c7505c0797230455fe5d972c374db", "warmup_time": -1}, "bench_array_coercion.ArrayCoercionSmall.time_array_all_kwargs": {"code": "class ArrayCoercionSmall:\n    def time_array_all_kwargs(self, array_like):\n        np.array(array_like, dtype=self.int64, copy=False, order=\"F\",\n                 subok=False, ndmin=2)", "min_run_count": 2, "name": "bench_array_coercion.ArrayCoercionSmall.time_array_all_kwargs", "number": 0, "param_names": ["array_like"], "params": [["range(0, 3)", "[1]", "1", "array([5])", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "73eadb209fbfe29b1d19131b50da1944b47d7d9b6cd59fe64b8c6e4fee177a81", "warmup_time": -1}, "bench_array_coercion.ArrayCoercionSmall.time_array_dtype_not_kwargs": {"code": "class ArrayCoercionSmall:\n    def time_array_dtype_not_kwargs(self, array_like):\n        np.array(array_like, self.int64)", "min_run_count": 2, "name": "bench_array_coercion.ArrayCoercionSmall.time_array_dtype_not_kwargs", "number": 0, "param_names": ["array_like"], "params": [["range(0, 3)", "[1]", "1", "array([5])", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7406ad0e996196d58688b676695446cdc1975aec380a82035209732e57ae47b8", "warmup_time": -1}, "bench_array_coercion.ArrayCoercionSmall.time_array_invalid_kwarg": {"code": "class ArrayCoercionSmall:\n    def time_array_invalid_kwarg(self, array_like):\n        try:\n            np.array(array_like, ndmin=\"not-integer\")\n        except TypeError:\n            pass", "min_run_count": 2, "name": "bench_array_coercion.ArrayCoercionSmall.time_array_invalid_kwarg", "number": 0, "param_names": ["array_like"], "params": [["range(0, 3)", "[1]", "1", "array([5])", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3cf138af2df1bdfa905afad9a2c8f4769ea6f86eef956764982c6922a78b59a8", "warmup_time": -1}, "bench_array_coercion.ArrayCoercionSmall.time_array_no_copy": {"code": "class ArrayCoercionSmall:\n    def time_array_no_copy(self, array_like):\n        np.array(array_like, copy=False)", "min_run_count": 2, "name": "bench_array_coercion.ArrayCoercionSmall.time_array_no_copy", "number": 0, "param_names": ["array_like"], "params": [["range(0, 3)", "[1]", "1", "array([5])", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "88c906bfc0bb2db2866043511e2198f6c40b7da5d143aabddd17a0b2c874ba75", "warmup_time": -1}, "bench_array_coercion.ArrayCoercionSmall.time_array_subok": {"code": "class ArrayCoercionSmall:\n    def time_array_subok(self, array_like):\n        np.array(array_like, subok=True)", "min_run_count": 2, "name": "bench_array_coercion.ArrayCoercionSmall.time_array_subok", "number": 0, "param_names": ["array_like"], "params": [["range(0, 3)", "[1]", "1", "array([5])", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2dc6919d9d4310f83b980f79ffd1353c7af92663d2ec75157574c06e7c075276", "warmup_time": -1}, "bench_array_coercion.ArrayCoercionSmall.time_asanyarray": {"code": "class ArrayCoercionSmall:\n    def time_asanyarray(self, array_like):\n        np.asarray(array_like)", "min_run_count": 2, "name": "bench_array_coercion.ArrayCoercionSmall.time_asanyarray", "number": 0, "param_names": ["array_like"], "params": [["range(0, 3)", "[1]", "1", "array([5])", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5cae35e9e843482299e48a8bc725e45abcd4e1e2b91f9929aa5f8e73f543fe0f", "warmup_time": -1}, "bench_array_coercion.ArrayCoercionSmall.time_asanyarray_dtype": {"code": "class ArrayCoercionSmall:\n    def time_asanyarray_dtype(self, array_like):\n        np.array(array_like, dtype=self.int64, order=\"F\")", "min_run_count": 2, "name": "bench_array_coercion.ArrayCoercionSmall.time_asanyarray_dtype", "number": 0, "param_names": ["array_like"], "params": [["range(0, 3)", "[1]", "1", "array([5])", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "886eeba38cd3f89302fd88a935d2bca574adcd81efadae0cd9dd96192b190c11", "warmup_time": -1}, "bench_array_coercion.ArrayCoercionSmall.time_asarray": {"code": "class ArrayCoercionSmall:\n    def time_asarray(self, array_like):\n        np.asarray(array_like)", "min_run_count": 2, "name": "bench_array_coercion.ArrayCoercionSmall.time_asarray", "number": 0, "param_names": ["array_like"], "params": [["range(0, 3)", "[1]", "1", "array([5])", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8fb148d93aa9d31468b9cdfa937d40b8fe600c94ff71e244f7153884f3ccf4c1", "warmup_time": -1}, "bench_array_coercion.ArrayCoercionSmall.time_asarray_dtype": {"code": "class ArrayCoercionSmall:\n    def time_asarray_dtype(self, array_like):\n        np.array(array_like, dtype=self.int64, order=\"F\")", "min_run_count": 2, "name": "bench_array_coercion.ArrayCoercionSmall.time_asarray_dtype", "number": 0, "param_names": ["array_like"], "params": [["range(0, 3)", "[1]", "1", "array([5])", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9833180cc455adb4341c01da14cfdcd6a69c09dc896d8fd05da4b21a56b11e54", "warmup_time": -1}, "bench_array_coercion.ArrayCoercionSmall.time_ascontiguousarray": {"code": "class ArrayCoercionSmall:\n    def time_ascontiguousarray(self, array_like):\n        np.ascontiguousarray(array_like)", "min_run_count": 2, "name": "bench_array_coercion.ArrayCoercionSmall.time_ascontiguousarray", "number": 0, "param_names": ["array_like"], "params": [["range(0, 3)", "[1]", "1", "array([5])", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "274ebaa23a30c9368e2ff6d82c13b62ec653a7d4736f01f1fa8921021769aea1", "warmup_time": -1}, "bench_core.Core.time_arange_100": {"code": "class Core:\n    def time_arange_100(self):\n        np.arange(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_arange_100", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9810ff39cf0d90038a0f034783bd846b9b7de314928b7ed9b77a9db9ab62a515", "warmup_time": -1}, "bench_core.Core.time_array_1": {"code": "class Core:\n    def time_array_1(self):\n        np.array(1)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_array_1", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "aebef56aaf9fb83a7a269cd2353e0e3ee094f80cd9aa5ee2224a71dec34d1b08", "warmup_time": -1}, "bench_core.Core.time_array_empty": {"code": "class Core:\n    def time_array_empty(self):\n        np.array([])\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_array_empty", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9a1586e568107cf4face75cecd6781c6359af578ef730c85a4f752eec1dbaa9a", "warmup_time": -1}, "bench_core.Core.time_array_float64_l1000": {"code": "class Core:\n    def time_array_float64_l1000(self):\n        np.array(self.float64_l1000)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_array_float64_l1000", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ccc5ca6d62274d036ae686dadc52f3d09e242ad9cd57d2c408da0b39d1943914", "warmup_time": -1}, "bench_core.Core.time_array_float_l1000": {"code": "class Core:\n    def time_array_float_l1000(self):\n        np.array(self.float_l1000)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_array_float_l1000", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "461053b7868bf5b2057d2bab87037b5e07c6cf938871cb3766b44a69b8270f18", "warmup_time": -1}, "bench_core.Core.time_array_float_l1000_dtype": {"code": "class Core:\n    def time_array_float_l1000_dtype(self):\n        np.array(self.float_l1000, dtype=self.float64_dtype)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_array_float_l1000_dtype", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3bb7c63d26535c89a4bddc30b2aa5f74488ffae091736b6622e911af9a30ae1f", "warmup_time": -1}, "bench_core.Core.time_array_int_l1000": {"code": "class Core:\n    def time_array_int_l1000(self):\n        np.array(self.int_l1000)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_array_int_l1000", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "89e8dee6420ae63d274cc4a6beb3038a46fbd62faf80b1e485adb3a00ad4a359", "warmup_time": -1}, "bench_core.Core.time_array_l": {"code": "class Core:\n    def time_array_l(self):\n        np.array(self.l)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_array_l", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "68192f51161df9d033cd5f2090e414b700ecf573b2e9000b0c534223dbbd1289", "warmup_time": -1}, "bench_core.Core.time_array_l1": {"code": "class Core:\n    def time_array_l1(self):\n        np.array([1])\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_array_l1", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "241cdb1e469ff23c8c0308f3ff7813b606f280f0100c323d4ee3ae9f85da5595", "warmup_time": -1}, "bench_core.Core.time_array_l100": {"code": "class Core:\n    def time_array_l100(self):\n        np.array(self.l100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_array_l100", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d704ac86a6671472c3625d12d6408848665f9db0ce76872e4893c6444287df7a", "warmup_time": -1}, "bench_core.Core.time_array_l_view": {"code": "class Core:\n    def time_array_l_view(self):\n        np.array(self.l_view)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_array_l_view", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ece084f922536234f4dd58a4601dbcbebf246861708e32f5d4051d21acbae2b8", "warmup_time": -1}, "bench_core.Core.time_diag_l100": {"code": "class Core:\n    def time_diag_l100(self):\n        np.diag(self.l100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_diag_l100", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6e62ecc1856911a7a4997e46036370168fbcef6da55f9cdc14425052fd6af8a3", "warmup_time": -1}, "bench_core.Core.time_diagflat_l100": {"code": "class Core:\n    def time_diagflat_l100(self):\n        np.diagflat(self.l100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_diagflat_l100", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "cf3eeccf300cf54e62332841fe4e1d22f44208d6b3a264cb5a2260121fd752bd", "warmup_time": -1}, "bench_core.Core.time_diagflat_l50_l50": {"code": "class Core:\n    def time_diagflat_l50_l50(self):\n        np.diagflat([self.l50, self.l50])\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_diagflat_l50_l50", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d2b890e26851599c8e29b40dbdabc8dbf1fa8dd62196cccbf9666f96e6f8e2e3", "warmup_time": -1}, "bench_core.Core.time_dstack_l": {"code": "class Core:\n    def time_dstack_l(self):\n        np.dstack(self.l)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_dstack_l", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "61b3007741cca1eb312f112e40a2f4904676511eed1d9717f70f35d37d4e69fe", "warmup_time": -1}, "bench_core.Core.time_empty_100": {"code": "class Core:\n    def time_empty_100(self):\n        np.empty(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_empty_100", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "559d67381ed0945a2d30dd05ea10953cb54301944e11e550dd7cda8b87253ca5", "warmup_time": -1}, "bench_core.Core.time_eye_100": {"code": "class Core:\n    def time_eye_100(self):\n        np.eye(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_eye_100", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "56a9ccc305d01ef5ac1e6fa57132076e313f1806b7b24edf967e272484072655", "warmup_time": -1}, "bench_core.Core.time_eye_3000": {"code": "class Core:\n    def time_eye_3000(self):\n        np.eye(3000)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_eye_3000", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "824c99e7affa09c806961a580afaa51cf639bc65ddb114543fc2fe22952f33ff", "warmup_time": -1}, "bench_core.Core.time_hstack_l": {"code": "class Core:\n    def time_hstack_l(self):\n        np.hstack(self.l)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_hstack_l", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "144b89def72fc1ce8633c9877160d7e1ef3e5d60fcca6715f3baff628acde755", "warmup_time": -1}, "bench_core.Core.time_identity_100": {"code": "class Core:\n    def time_identity_100(self):\n        np.identity(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_identity_100", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d46f8b9fda8d7af1e55aaee2a9707a32f556309f127f324c3f0f9e14577f9c84", "warmup_time": -1}, "bench_core.Core.time_identity_3000": {"code": "class Core:\n    def time_identity_3000(self):\n        np.identity(3000)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_identity_3000", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f25f09f407fc0ec65996e154ce1acc3605fbfc1956b2e45ab7a8be95eabe9742", "warmup_time": -1}, "bench_core.Core.time_ones_100": {"code": "class Core:\n    def time_ones_100(self):\n        np.ones(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_ones_100", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f5f2fda543a06557ed577505581a4e4a69c28db7f4d56d15e3a5ab70c5836ad1", "warmup_time": -1}, "bench_core.Core.time_tril_indices_500": {"code": "class Core:\n    def time_tril_indices_500(self):\n        np.tril_indices(500)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_tril_indices_500", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b00c8c298dd9483448ee0601526273d6576350e7cbff10d47b606a7182b9ee51", "warmup_time": -1}, "bench_core.Core.time_tril_l10x10": {"code": "class Core:\n    def time_tril_l10x10(self):\n        np.tril(self.l10x10)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_tril_l10x10", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "52a8d958bc2f0d6641959d60b4e362bd13ff07ad07cb91f67c86c1371049d522", "warmup_time": -1}, "bench_core.Core.time_triu_indices_500": {"code": "class Core:\n    def time_triu_indices_500(self):\n        np.triu_indices(500)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_triu_indices_500", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e67074fcc7b979a87a1080d3203b5ed9afac0744671de5d1ffb13cba5e2c27f4", "warmup_time": -1}, "bench_core.Core.time_triu_l10x10": {"code": "class Core:\n    def time_triu_l10x10(self):\n        np.triu(self.l10x10)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_triu_l10x10", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "450bc906f82b3446c2c3ce69ea043137dc643848b9378c0387b7f50b18e99216", "warmup_time": -1}, "bench_core.Core.time_vstack_l": {"code": "class Core:\n    def time_vstack_l(self):\n        np.vstack(self.l)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_vstack_l", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1287e18f3b28dadd8b9aca804e354546ffb3b238647b20cf3667d86e88c9412e", "warmup_time": -1}, "bench_core.Core.time_zeros_100": {"code": "class Core:\n    def time_zeros_100(self):\n        np.zeros(100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.l50 = range(50)\n        self.float_l1000 = [float(i) for i in range(1000)]\n        self.float64_l1000 = [np.float64(i) for i in range(1000)]\n        self.int_l1000 = list(range(1000))\n        self.l = [np.arange(1000), np.arange(1000)]\n        self.l_view = [memoryview(a) for a in self.l]\n        self.l10x10 = np.ones((10, 10))\n        self.float64_dtype = np.dtype(np.float64)", "min_run_count": 2, "name": "bench_core.Core.time_zeros_100", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "206e21887f58c043e2d286405ddabefa934a6cecc80fbe3045636dee7df139a4", "warmup_time": -1}, "bench_core.CorrConv.time_convolve": {"code": "class CorrConv:\n    def time_convolve(self, size1, size2, mode):\n        np.convolve(self.x1, self.x2, mode=mode)\n\n    def setup(self, size1, size2, mode):\n        self.x1 = np.linspace(0, 1, num=size1)\n        self.x2 = np.cos(np.linspace(0, 2*np.pi, num=size2))", "min_run_count": 2, "name": "bench_core.CorrConv.time_convolve", "number": 0, "param_names": ["size1", "size2", "mode"], "params": [["50", "1000", "100000"], ["10", "100", "1000", "10000"], ["'valid'", "'same'", "'full'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "110934cc16c781cf51ef05e32d0376573f652f8d29632088314c80bb280373f5", "warmup_time": -1}, "bench_core.CorrConv.time_correlate": {"code": "class CorrConv:\n    def time_correlate(self, size1, size2, mode):\n        np.correlate(self.x1, self.x2, mode=mode)\n\n    def setup(self, size1, size2, mode):\n        self.x1 = np.linspace(0, 1, num=size1)\n        self.x2 = np.cos(np.linspace(0, 2*np.pi, num=size2))", "min_run_count": 2, "name": "bench_core.CorrConv.time_correlate", "number": 0, "param_names": ["size1", "size2", "mode"], "params": [["50", "1000", "100000"], ["10", "100", "1000", "10000"], ["'valid'", "'same'", "'full'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9add985c37891263767f640a8caa0571b67ad9fc64587e26fa1403cdbfd46a20", "warmup_time": -1}, "bench_core.CountNonzero.time_count_nonzero": {"code": "class CountNonzero:\n    def time_count_nonzero(self, numaxes, size, dtype):\n        np.count_nonzero(self.x)\n\n    def setup(self, numaxes, size, dtype):\n        self.x = np.arange(numaxes * size).reshape(numaxes, size)\n        self.x = (self.x % 3).astype(dtype)", "min_run_count": 2, "name": "bench_core.CountNonzero.time_count_nonzero", "number": 0, "param_names": ["numaxes", "size", "dtype"], "params": [["1", "2", "3"], ["100", "10000", "1000000"], ["<class 'bool'>", "<class 'numpy.int8'>", "<class 'numpy.int16'>", "<class 'numpy.int32'>", "<class 'numpy.int64'>", "<class 'str'>", "<class 'object'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "62b6e7f8cdf194df64c7d1c6948ebe3b15027b688ac851c288b08bf147ea21c4", "warmup_time": -1}, "bench_core.CountNonzero.time_count_nonzero_axis": {"code": "class CountNonzero:\n    def time_count_nonzero_axis(self, numaxes, size, dtype):\n        np.count_nonzero(self.x, axis=self.x.ndim - 1)\n\n    def setup(self, numaxes, size, dtype):\n        self.x = np.arange(numaxes * size).reshape(numaxes, size)\n        self.x = (self.x % 3).astype(dtype)", "min_run_count": 2, "name": "bench_core.CountNonzero.time_count_nonzero_axis", "number": 0, "param_names": ["numaxes", "size", "dtype"], "params": [["1", "2", "3"], ["100", "10000", "1000000"], ["<class 'bool'>", "<class 'numpy.int8'>", "<class 'numpy.int16'>", "<class 'numpy.int32'>", "<class 'numpy.int64'>", "<class 'str'>", "<class 'object'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0af13d073c97801eefc841f06735f316331f6898842d60d7077063e761cc3399", "warmup_time": -1}, "bench_core.CountNonzero.time_count_nonzero_multi_axis": {"code": "class CountNonzero:\n    def time_count_nonzero_multi_axis(self, numaxes, size, dtype):\n        if self.x.ndim >= 2:\n            np.count_nonzero(self.x, axis=(\n                self.x.ndim - 1, self.x.ndim - 2))\n\n    def setup(self, numaxes, size, dtype):\n        self.x = np.arange(numaxes * size).reshape(numaxes, size)\n        self.x = (self.x % 3).astype(dtype)", "min_run_count": 2, "name": "bench_core.CountNonzero.time_count_nonzero_multi_axis", "number": 0, "param_names": ["numaxes", "size", "dtype"], "params": [["1", "2", "3"], ["100", "10000", "1000000"], ["<class 'bool'>", "<class 'numpy.int8'>", "<class 'numpy.int16'>", "<class 'numpy.int32'>", "<class 'numpy.int64'>", "<class 'str'>", "<class 'object'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "539135a464660d1aa5d3e83d59b995843997e3e31d51e8e284bfbd83ddad52d3", "warmup_time": -1}, "bench_core.Indices.time_indices": {"code": "class Indices:\n    def time_indices(self):\n        np.indices((1000, 500))", "min_run_count": 2, "name": "bench_core.Indices.time_indices", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2e230aa0719ef3ade68215df513a0a9aafa9d052ee5c2665559e3cea10bf9b51", "warmup_time": -1}, "bench_core.PackBits.time_packbits": {"code": "class PackBits:\n    def time_packbits(self, dtype):\n        np.packbits(self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(10000, dtype=dtype)\n        self.d2 = np.ones((200, 1000), dtype=dtype)", "min_run_count": 2, "name": "bench_core.PackBits.time_packbits", "number": 0, "param_names": ["dtype"], "params": [["<class 'bool'>", "<class 'numpy.uint64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1e1cdd058f7cb55eb592d5d4a6d37273683a1ab55041e8c4b4ef7c29e5e55313", "warmup_time": -1}, "bench_core.PackBits.time_packbits_axis0": {"code": "class PackBits:\n    def time_packbits_axis0(self, dtype):\n        np.packbits(self.d2, axis=0)\n\n    def setup(self, dtype):\n        self.d = np.ones(10000, dtype=dtype)\n        self.d2 = np.ones((200, 1000), dtype=dtype)", "min_run_count": 2, "name": "bench_core.PackBits.time_packbits_axis0", "number": 0, "param_names": ["dtype"], "params": [["<class 'bool'>", "<class 'numpy.uint64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3596f631e5980c6f39f8af219cc1bd8bc6cb97ed103fbb9008368ce8e4510c0c", "warmup_time": -1}, "bench_core.PackBits.time_packbits_axis1": {"code": "class PackBits:\n    def time_packbits_axis1(self, dtype):\n        np.packbits(self.d2, axis=1)\n\n    def setup(self, dtype):\n        self.d = np.ones(10000, dtype=dtype)\n        self.d2 = np.ones((200, 1000), dtype=dtype)", "min_run_count": 2, "name": "bench_core.PackBits.time_packbits_axis1", "number": 0, "param_names": ["dtype"], "params": [["<class 'bool'>", "<class 'numpy.uint64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "138b6e3b289ecabf2012d7d40274f69f848fc241c53fe21eb8dcf5ff77dc3dd2", "warmup_time": -1}, "bench_core.PackBits.time_packbits_little": {"code": "class PackBits:\n    def time_packbits_little(self, dtype):\n        np.packbits(self.d, bitorder=\"little\")\n\n    def setup(self, dtype):\n        self.d = np.ones(10000, dtype=dtype)\n        self.d2 = np.ones((200, 1000), dtype=dtype)", "min_run_count": 2, "name": "bench_core.PackBits.time_packbits_little", "number": 0, "param_names": ["dtype"], "params": [["<class 'bool'>", "<class 'numpy.uint64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b40e33398c541441ca74f3b9af0da0e187cd290dcb8f1c4040cd21b942212b93", "warmup_time": -1}, "bench_core.Temporaries.time_large": {"code": "class Temporaries:\n    def time_large(self):\n        (self.alarge * 2) + self.blarge\n\n    def setup(self):\n        self.amid = np.ones(50000)\n        self.bmid = np.ones(50000)\n        self.alarge = np.ones(1000000)\n        self.blarge = np.ones(1000000)", "min_run_count": 2, "name": "bench_core.Temporaries.time_large", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d1f17784ab0409272af0ac08b2609f381d7257185a54f102e5114b3f8548fbf3", "warmup_time": -1}, "bench_core.Temporaries.time_large2": {"code": "class Temporaries:\n    def time_large2(self):\n        (self.alarge + self.blarge) - 2\n\n    def setup(self):\n        self.amid = np.ones(50000)\n        self.bmid = np.ones(50000)\n        self.alarge = np.ones(1000000)\n        self.blarge = np.ones(1000000)", "min_run_count": 2, "name": "bench_core.Temporaries.time_large2", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "23dea77757706f4d1d936f725e42bdc67c57d9b2f919e4da807d26ffe127ca51", "warmup_time": -1}, "bench_core.Temporaries.time_mid": {"code": "class Temporaries:\n    def time_mid(self):\n        (self.amid * 2) + self.bmid\n\n    def setup(self):\n        self.amid = np.ones(50000)\n        self.bmid = np.ones(50000)\n        self.alarge = np.ones(1000000)\n        self.blarge = np.ones(1000000)", "min_run_count": 2, "name": "bench_core.Temporaries.time_mid", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ad3406f4f9a8d7ad3c489e9028cedc12079758fe89272347756b7ea6e011a267", "warmup_time": -1}, "bench_core.Temporaries.time_mid2": {"code": "class Temporaries:\n    def time_mid2(self):\n        (self.amid + self.bmid) - 2\n\n    def setup(self):\n        self.amid = np.ones(50000)\n        self.bmid = np.ones(50000)\n        self.alarge = np.ones(1000000)\n        self.blarge = np.ones(1000000)", "min_run_count": 2, "name": "bench_core.Temporaries.time_mid2", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5ad422ecaa9af109188d4d1fcb95cdfe8fce8d2ed999ef8a241e3af3f1677bbe", "warmup_time": -1}, "bench_core.UnpackBits.time_unpackbits": {"code": "class UnpackBits:\n    def time_unpackbits(self):\n        np.unpackbits(self.d)\n\n    def setup(self):\n        self.d = np.ones(10000, dtype=np.uint8)\n        self.d2 = np.ones((200, 1000), dtype=np.uint8)", "min_run_count": 2, "name": "bench_core.UnpackBits.time_unpackbits", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8a9b8fdeeee1d01e42caff6c2cd0efc371c72053e373203f670f49c399a19ef2", "warmup_time": -1}, "bench_core.UnpackBits.time_unpackbits_axis0": {"code": "class UnpackBits:\n    def time_unpackbits_axis0(self):\n        np.unpackbits(self.d2, axis=0)\n\n    def setup(self):\n        self.d = np.ones(10000, dtype=np.uint8)\n        self.d2 = np.ones((200, 1000), dtype=np.uint8)", "min_run_count": 2, "name": "bench_core.UnpackBits.time_unpackbits_axis0", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b842c713e8a843ac2273fe2f17c174ecd27b28a6dace841dac2a13d913caa8f7", "warmup_time": -1}, "bench_core.UnpackBits.time_unpackbits_axis1": {"code": "class UnpackBits:\n    def time_unpackbits_axis1(self):\n        np.unpackbits(self.d2, axis=1)\n\n    def setup(self):\n        self.d = np.ones(10000, dtype=np.uint8)\n        self.d2 = np.ones((200, 1000), dtype=np.uint8)", "min_run_count": 2, "name": "bench_core.UnpackBits.time_unpackbits_axis1", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7ac672e3d48251be042a8a5e4b8167dbb3b91f0af99b4f01f9d9287e7561cd73", "warmup_time": -1}, "bench_core.UnpackBits.time_unpackbits_axis1_little": {"code": "class UnpackBits:\n    def time_unpackbits_axis1_little(self):\n        np.unpackbits(self.d2, bitorder=\"little\", axis=1)\n\n    def setup(self):\n        self.d = np.ones(10000, dtype=np.uint8)\n        self.d2 = np.ones((200, 1000), dtype=np.uint8)", "min_run_count": 2, "name": "bench_core.UnpackBits.time_unpackbits_axis1_little", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6449672a44b525868dbb66b244d23b3cc985ed6310b7c63a3d360091748497fa", "warmup_time": -1}, "bench_core.UnpackBits.time_unpackbits_little": {"code": "class UnpackBits:\n    def time_unpackbits_little(self):\n        np.unpackbits(self.d, bitorder=\"little\")\n\n    def setup(self):\n        self.d = np.ones(10000, dtype=np.uint8)\n        self.d2 = np.ones((200, 1000), dtype=np.uint8)", "min_run_count": 2, "name": "bench_core.UnpackBits.time_unpackbits_little", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "074fea3cb327abbd97e59f2acf3ae2eaefb70020bdef1cab122a9190ee139eb8", "warmup_time": -1}, "bench_core.VarComplex.time_var": {"code": "class VarComplex:\n    def time_var(self, n):\n        self.arr.var()\n\n    def setup(self, n):\n        self.arr = np.random.randn(n) + 1j * np.random.randn(n)", "min_run_count": 2, "name": "bench_core.VarComplex.time_var", "number": 0, "param_names": ["param1"], "params": [["1", "10", "100", "1000", "10000", "100000", "1000000", "10000000", "100000000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "343d0479b33167dfc332d453e32b8710ee17a22fb693a3856575aa9dfad0d49d", "warmup_time": -1}, "bench_function_base.Bincount.time_bincount": {"code": "class Bincount:\n    def time_bincount(self):\n        np.bincount(self.d)\n\n    def setup(self):\n        self.d = np.arange(80000, dtype=np.intp)\n        self.e = self.d.astype(np.float64)", "min_run_count": 2, "name": "bench_function_base.Bincount.time_bincount", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5d90f434eae543f580a5bb7f86e14c4663521f721b5a056155c61223dec781e4", "warmup_time": -1}, "bench_function_base.Bincount.time_weights": {"code": "class Bincount:\n    def time_weights(self):\n        np.bincount(self.d, weights=self.e)\n\n    def setup(self):\n        self.d = np.arange(80000, dtype=np.intp)\n        self.e = self.d.astype(np.float64)", "min_run_count": 2, "name": "bench_function_base.Bincount.time_weights", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "21806334def6c126f9bb25e7ed2a2e4d9be995f373cd288727bb4d8e33bb11cb", "warmup_time": -1}, "bench_function_base.Histogram1D.time_fine_binning": {"code": "class Histogram1D:\n    def time_fine_binning(self):\n        np.histogram(self.d, 10000, (0, 100))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 100000)", "min_run_count": 2, "name": "bench_function_base.Histogram1D.time_fine_binning", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fd9a7cd0ee34b75f9eddd8c022b58b149397c82b4bd22de6fdb8b6e23c72e19c", "warmup_time": -1}, "bench_function_base.Histogram1D.time_full_coverage": {"code": "class Histogram1D:\n    def time_full_coverage(self):\n        np.histogram(self.d, 200, (0, 100))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 100000)", "min_run_count": 2, "name": "bench_function_base.Histogram1D.time_full_coverage", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7a6b3163b94451004a6b27ea9f14f9aa6c0e86e437074c1558a53ad422af141a", "warmup_time": -1}, "bench_function_base.Histogram1D.time_small_coverage": {"code": "class Histogram1D:\n    def time_small_coverage(self):\n        np.histogram(self.d, 200, (50, 51))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 100000)", "min_run_count": 2, "name": "bench_function_base.Histogram1D.time_small_coverage", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "324b8676b5ae4c324e05671ffe2058af996d3cb540d845b6701cbae68eb26d99", "warmup_time": -1}, "bench_function_base.Histogram2D.time_fine_binning": {"code": "class Histogram2D:\n    def time_fine_binning(self):\n        np.histogramdd(self.d, (10000, 10000), ((0, 100), (0, 100)))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 200000).reshape((-1,2))", "min_run_count": 2, "name": "bench_function_base.Histogram2D.time_fine_binning", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2f6f1c99fb221c95e8526dc863c8b1e72546468bf162e20e62539f171241ceae", "warmup_time": -1}, "bench_function_base.Histogram2D.time_full_coverage": {"code": "class Histogram2D:\n    def time_full_coverage(self):\n        np.histogramdd(self.d, (200, 200), ((0, 100), (0, 100)))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 200000).reshape((-1,2))", "min_run_count": 2, "name": "bench_function_base.Histogram2D.time_full_coverage", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "79d7122f11109af1751f17c3a36c5df88fa3cbb842d49a9859528c7ea37eaf4f", "warmup_time": -1}, "bench_function_base.Histogram2D.time_small_coverage": {"code": "class Histogram2D:\n    def time_small_coverage(self):\n        np.histogramdd(self.d, (200, 200), ((50, 51), (50, 51)))\n\n    def setup(self):\n        self.d = np.linspace(0, 100, 200000).reshape((-1,2))", "min_run_count": 2, "name": "bench_function_base.Histogram2D.time_small_coverage", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e8ff2855bc11b18b68832bbd0917468aab6b272a86ec5cf2fd1ac46d3e39adf5", "warmup_time": -1}, "bench_function_base.Linspace.time_linspace_array": {"code": "class Linspace:\n    def time_linspace_array(self):\n        np.linspace(self.d, 10, 10)\n\n    def setup(self):\n        self.d = np.array([1, 2, 3])", "min_run_count": 2, "name": "bench_function_base.Linspace.time_linspace_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "57b4f4afbd30dad37d722535cb96d47814371aae36f9741ef0bbdbcbbaebbb46", "warmup_time": -1}, "bench_function_base.Linspace.time_linspace_scalar": {"code": "class Linspace:\n    def time_linspace_scalar(self):\n        np.linspace(0, 10, 2)\n\n    def setup(self):\n        self.d = np.array([1, 2, 3])", "min_run_count": 2, "name": "bench_function_base.Linspace.time_linspace_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "218e16d138735dfe5dbdb5a236e56828262bd70df1bc989156dcec0083b9ffd5", "warmup_time": -1}, "bench_function_base.Mean.time_mean": {"code": "class Mean:\n    def time_mean(self, size):\n        np.mean(self.array)\n\n    def setup(self, size):\n        self.array = np.arange(2*size).reshape(2, size)", "min_run_count": 2, "name": "bench_function_base.Mean.time_mean", "number": 0, "param_names": ["size"], "params": [["1", "10", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9806666f70037d09e27ef0b2f913b58de154149c5adc3f1ba930288d1a95890a", "warmup_time": -1}, "bench_function_base.Mean.time_mean_axis": {"code": "class Mean:\n    def time_mean_axis(self, size):\n        np.mean(self.array, axis=1)\n\n    def setup(self, size):\n        self.array = np.arange(2*size).reshape(2, size)", "min_run_count": 2, "name": "bench_function_base.Mean.time_mean_axis", "number": 0, "param_names": ["size"], "params": [["1", "10", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "48f7840dd4a24e2077ecef160e67ad5b3e182769b1445ec3f482e5cf86d2569e", "warmup_time": -1}, "bench_function_base.Median.time_even": {"code": "class Median:\n    def time_even(self):\n        np.median(self.e)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))", "min_run_count": 2, "name": "bench_function_base.Median.time_even", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "13b3b69fccb37edf9506bbda2fc94d186da8c807a7b327a06594a505019f2f2f", "warmup_time": -1}, "bench_function_base.Median.time_even_inplace": {"code": "class Median:\n    def time_even_inplace(self):\n        np.median(self.e, overwrite_input=True)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))", "min_run_count": 2, "name": "bench_function_base.Median.time_even_inplace", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "66ab8767b044f8bba391dcde907bc3f8adaaa5ed6d3bdc98f8cd145c3d1504dc", "warmup_time": -1}, "bench_function_base.Median.time_even_small": {"code": "class Median:\n    def time_even_small(self):\n        np.median(self.e[:500], overwrite_input=True)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))", "min_run_count": 2, "name": "bench_function_base.Median.time_even_small", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7e875480f5efc782650ad82c3da3b98e1c792c1a0ef6909b6f4ca34723f5f74a", "warmup_time": -1}, "bench_function_base.Median.time_odd": {"code": "class Median:\n    def time_odd(self):\n        np.median(self.o)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))", "min_run_count": 2, "name": "bench_function_base.Median.time_odd", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c9387484b60ca2a29af6a76b204e2e946707a510ce8f0cf34ad94034e60fa9f4", "warmup_time": -1}, "bench_function_base.Median.time_odd_inplace": {"code": "class Median:\n    def time_odd_inplace(self):\n        np.median(self.o, overwrite_input=True)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))", "min_run_count": 2, "name": "bench_function_base.Median.time_odd_inplace", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "247fb9cabd1120f968f253104e257b12ee43dfdccd615442560ee3fc19c73f19", "warmup_time": -1}, "bench_function_base.Median.time_odd_small": {"code": "class Median:\n    def time_odd_small(self):\n        np.median(self.o[:500], overwrite_input=True)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))", "min_run_count": 2, "name": "bench_function_base.Median.time_odd_small", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ca5ae3c9b420da70652d3804e6ed8c638ebce887f7e8bf1ea47eeeac067f0dc5", "warmup_time": -1}, "bench_function_base.Median.time_tall": {"code": "class Median:\n    def time_tall(self):\n        np.median(self.tall, axis=-1)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))", "min_run_count": 2, "name": "bench_function_base.Median.time_tall", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "cdd4fd8c870b9317004bded6790f3ee97e061fda9c111d1ff931f73a65f45800", "warmup_time": -1}, "bench_function_base.Median.time_wide": {"code": "class Median:\n    def time_wide(self):\n        np.median(self.wide, axis=0)\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(10001, dtype=np.float32)\n        self.tall = np.random.random((10000, 20))\n        self.wide = np.random.random((20, 10000))", "min_run_count": 2, "name": "bench_function_base.Median.time_wide", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2cc4f8b970b0002377700dcbd509c1ee53cb30b8ce8e3703b2a50af674db3d4d", "warmup_time": -1}, "bench_function_base.Percentile.time_percentile": {"code": "class Percentile:\n    def time_percentile(self):\n        np.percentile(self.e, [25, 35, 55, 65, 75])\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(21, dtype=np.float32)", "min_run_count": 2, "name": "bench_function_base.Percentile.time_percentile", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f5bf2ff405d84895a820e0a9c9f2435f5b989d3c317e9e5c736d92cebb339eee", "warmup_time": -1}, "bench_function_base.Percentile.time_percentile_small": {"code": "class Percentile:\n    def time_percentile_small(self):\n        np.percentile(self.o, [25, 75])\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(21, dtype=np.float32)", "min_run_count": 2, "name": "bench_function_base.Percentile.time_percentile_small", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "78f7977cc6db145459abc795273ceb862115cf2eb50ebe09caef0b0dea19be6f", "warmup_time": -1}, "bench_function_base.Percentile.time_quartile": {"code": "class Percentile:\n    def time_quartile(self):\n        np.percentile(self.e, [25, 75])\n\n    def setup(self):\n        self.e = np.arange(10000, dtype=np.float32)\n        self.o = np.arange(21, dtype=np.float32)", "min_run_count": 2, "name": "bench_function_base.Percentile.time_quartile", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "766b2fd824cb705705ac99667737eb621cd8106bcf8b696ac89d12f20ac47474", "warmup_time": -1}, "bench_function_base.Select.time_select": {"code": "class Select:\n    def time_select(self):\n        np.select(self.cond, [self.d, self.e])\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = [(self.d > 4), (self.d < 2)]\n        self.cond_large = [(self.d > 4), (self.d < 2)] * 10", "min_run_count": 2, "name": "bench_function_base.Select.time_select", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "89f02a048ace03b6c3269e61811da1ece2dab2a456536225dafaccbc385920a7", "warmup_time": -1}, "bench_function_base.Select.time_select_larger": {"code": "class Select:\n    def time_select_larger(self):\n        np.select(self.cond_large, ([self.d, self.e] * 10))\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = [(self.d > 4), (self.d < 2)]\n        self.cond_large = [(self.d > 4), (self.d < 2)] * 10", "min_run_count": 2, "name": "bench_function_base.Select.time_select_larger", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a702e09750946268c44bce105934f13f28b8abe05f71a1f660e967804fafd305", "warmup_time": -1}, "bench_function_base.Sort.time_argsort": {"code": "class Sort:\n    def time_argsort(self, kind, dtype, array_type):\n        np.argsort(self.arr, kind=kind)\n\n    def setup(self, kind, dtype, array_type):\n        np.random.seed(1234)\n        array_class = array_type[0]\n        self.arr = getattr(SortGenerator, array_class)(self.ARRAY_SIZE, dtype, *array_type[1:])", "min_run_count": 2, "name": "bench_function_base.Sort.time_argsort", "number": 0, "param_names": ["kind", "dtype", "array_type"], "params": [["'quick'", "'merge'", "'heap'"], ["'float64'", "'int64'", "'float32'", "'uint32'", "'int32'", "'int16'"], ["('random',)", "('ordered',)", "('reversed',)", "('uniform',)", "('sorted_block', 10)", "('sorted_block', 100)", "('sorted_block', 1000)"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "624eb47572c94efd36b968e9d3bc7e0626f4bbf3e7578adaa6abc977cd03c833", "warmup_time": -1}, "bench_function_base.Sort.time_sort": {"code": "class Sort:\n    def time_sort(self, kind, dtype, array_type):\n        # Using np.sort(...) instead of arr.sort(...) because it makes a copy.\n        # This is important because the data is prepared once per benchmark, but\n        # used across multiple runs.\n        np.sort(self.arr, kind=kind)\n\n    def setup(self, kind, dtype, array_type):\n        np.random.seed(1234)\n        array_class = array_type[0]\n        self.arr = getattr(SortGenerator, array_class)(self.ARRAY_SIZE, dtype, *array_type[1:])", "min_run_count": 2, "name": "bench_function_base.Sort.time_sort", "number": 0, "param_names": ["kind", "dtype", "array_type"], "params": [["'quick'", "'merge'", "'heap'"], ["'float64'", "'int64'", "'float32'", "'uint32'", "'int32'", "'int16'"], ["('random',)", "('ordered',)", "('reversed',)", "('uniform',)", "('sorted_block', 10)", "('sorted_block', 100)", "('sorted_block', 1000)"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1fa0d392d237dcaa96c29d3fe5e59749ebb9bfd9e79f9bd3d4f00e0def335ae0", "warmup_time": -1}, "bench_function_base.Sort.time_sort_worst": {"code": "class SortWorst:\n    def time_sort_worst(self):\n        np.sort(self.worst)\n\n    def setup(self):\n        # quicksort median of 3 worst case\n        self.worst = np.arange(1000000)\n        x = self.worst\n        while x.size > 3:\n            mid = x.size // 2\n            x[mid], x[-2] = x[-2], x[mid]\n            x = x[:-2]", "min_run_count": 2, "name": "bench_function_base.Sort.time_sort_worst", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ace32d23c7f67f08c3993d54ad4d4b67cd9b56a42a8b95f830141cce64e1d6ec", "warmup_time": -1}, "bench_function_base.Where.time_1": {"code": "class Where:\n    def time_1(self):\n        np.where(self.cond)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_1", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a14eb505302aed7f8dda22787b55ff379074e0c08a99a23c8b1a9b733b294bbb", "warmup_time": -1}, "bench_function_base.Where.time_2": {"code": "class Where:\n    def time_2(self):\n        np.where(self.cond, self.d, self.e)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_2", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8b7dfd90aa98a3117d2d0f13ea1450a0f5f98400cf4a88e80659c415581260b9", "warmup_time": -1}, "bench_function_base.Where.time_2_broadcast": {"code": "class Where:\n    def time_2_broadcast(self):\n        np.where(self.cond, self.d, 0)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_2_broadcast", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "bb230883097328316257828f5a66083c573f297fab70a6385c30b99649425340", "warmup_time": -1}, "bench_function_base.Where.time_all_ones": {"code": "class Where:\n    def time_all_ones(self):\n        np.where(self.all_ones)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_all_ones", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c76c64e03f83ff3af09299b29976d037f0d1b5b6cf538ff16634b330dee55125", "warmup_time": -1}, "bench_function_base.Where.time_all_zeros": {"code": "class Where:\n    def time_all_zeros(self):\n        np.where(self.all_zeros)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_all_zeros", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "26ab3db03c4e01fb850fff6196b1b3888455d1e675c6ad9d579910b4df4073ca", "warmup_time": -1}, "bench_function_base.Where.time_interleaved_ones_x2": {"code": "class Where:\n    def time_interleaved_ones_x2(self):\n        np.where(self.rep_ones_2)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_interleaved_ones_x2", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c1c762a1bcf9457daea8ff677c399268ef20c9e0888e76895465f1d8cc5e4621", "warmup_time": -1}, "bench_function_base.Where.time_interleaved_ones_x4": {"code": "class Where:\n    def time_interleaved_ones_x4(self):\n        np.where(self.rep_ones_4)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_interleaved_ones_x4", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b5e5a68f9455db32298db53fb6fd155be6a37693b48bd31d94c412f348aafdd4", "warmup_time": -1}, "bench_function_base.Where.time_interleaved_ones_x8": {"code": "class Where:\n    def time_interleaved_ones_x8(self):\n        np.where(self.rep_ones_8)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_interleaved_ones_x8", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d9ee77693fb3ea6639bfe6f1acbeb6dc3df01cccd91bc749e142e4a691269126", "warmup_time": -1}, "bench_function_base.Where.time_interleaved_zeros_x2": {"code": "class Where:\n    def time_interleaved_zeros_x2(self):\n        np.where(self.rep_zeros_2)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_interleaved_zeros_x2", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b832cbe7027154667b0f817bf8f8280cc2643bd1d5b76f977a33508b189b9be9", "warmup_time": -1}, "bench_function_base.Where.time_interleaved_zeros_x4": {"code": "class Where:\n    def time_interleaved_zeros_x4(self):\n        np.where(self.rep_zeros_4)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_interleaved_zeros_x4", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "92949084dfe7e7e60cba62c9a987cc5ce8a9855a96ea37fc94cf0dbfe161f1bb", "warmup_time": -1}, "bench_function_base.Where.time_interleaved_zeros_x8": {"code": "class Where:\n    def time_interleaved_zeros_x8(self):\n        np.where(self.rep_zeros_8)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_interleaved_zeros_x8", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "eef5673f14a35eb05a86fcc1eb686a7a2d5b5c4eec94b33ee650945854efbfc8", "warmup_time": -1}, "bench_function_base.Where.time_random_01_percent": {"code": "class Where:\n    def time_random_01_percent(self):\n        np.where(self.rand_cond_01)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_random_01_percent", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "03af99f560f62c8a0739b0a3f4dfa1e4c425be4900a7529e02b2c0ac10beb134", "warmup_time": -1}, "bench_function_base.Where.time_random_20_percent": {"code": "class Where:\n    def time_random_20_percent(self):\n        np.where(self.rand_cond_20)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_random_20_percent", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ac4f3f7ad99395b6c740bbcf54a616cc9f151864690e56feae803356c56d4325", "warmup_time": -1}, "bench_function_base.Where.time_random_30_percent": {"code": "class Where:\n    def time_random_30_percent(self):\n        np.where(self.rand_cond_30)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_random_30_percent", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "86db5da25bab8ce0838fa5b15116a5d4d5ca0feae3c0717c830bc1ded370ee65", "warmup_time": -1}, "bench_function_base.Where.time_random_40_percent": {"code": "class Where:\n    def time_random_40_percent(self):\n        np.where(self.rand_cond_40)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_random_40_percent", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "819dda0c981a335c7bb8a59cff1388d03f5a4b63bed890259db8f66e09f23ad6", "warmup_time": -1}, "bench_function_base.Where.time_random_50_percent": {"code": "class Where:\n    def time_random_50_percent(self):\n        np.where(self.rand_cond_50)\n\n    def setup(self):\n        self.d = np.arange(20000)\n        self.e = self.d.copy()\n        self.cond = (self.d > 5000)\n        size = 1024 * 1024 // 8\n        rnd_array = np.random.rand(size)\n        self.rand_cond_01 = rnd_array > 0.01\n        self.rand_cond_20 = rnd_array > 0.20\n        self.rand_cond_30 = rnd_array > 0.30\n        self.rand_cond_40 = rnd_array > 0.40\n        self.rand_cond_50 = rnd_array > 0.50\n        self.all_zeros = np.zeros(size, dtype=bool)\n        self.all_ones = np.ones(size, dtype=bool)\n        self.rep_zeros_2 = np.arange(size) % 2 == 0\n        self.rep_zeros_4 = np.arange(size) % 4 == 0\n        self.rep_zeros_8 = np.arange(size) % 8 == 0\n        self.rep_ones_2 = np.arange(size) % 2 > 0\n        self.rep_ones_4 = np.arange(size) % 4 > 0\n        self.rep_ones_8 = np.arange(size) % 8 > 0", "min_run_count": 2, "name": "bench_function_base.Where.time_random_50_percent", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5e5e3af21be2f81a96eb4665373c1d302900d8f89c7d69b588406f9f2d35729a", "warmup_time": -1}, "bench_import.Import.time_fft": {"code": "class Import:\n    def time_fft(self):\n        self.execute('from numpy import fft')", "min_run_count": 2, "name": "bench_import.Import.time_fft", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "032a4b610918503dbb969cc5837be23961652784b6221173d38fa901e9811532", "warmup_time": -1}, "bench_import.Import.time_linalg": {"code": "class Import:\n    def time_linalg(self):\n        self.execute('from numpy import linalg')", "min_run_count": 2, "name": "bench_import.Import.time_linalg", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c39a1494b3509e08cf7735c691b237b7bea72c7ab9acc811567991c16104f2aa", "warmup_time": -1}, "bench_import.Import.time_ma": {"code": "class Import:\n    def time_ma(self):\n        self.execute('from numpy import ma')", "min_run_count": 2, "name": "bench_import.Import.time_ma", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8a42f579234af8dd0de6c97e2456192925e2089772dc64143802bc3d511757e1", "warmup_time": -1}, "bench_import.Import.time_matlib": {"code": "class Import:\n    def time_matlib(self):\n        self.execute('from numpy import matlib')", "min_run_count": 2, "name": "bench_import.Import.time_matlib", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1646af4cf76933a57faea27e4294eb5bacd6fa5fa3eb86f10e9e3f8db9a2cd57", "warmup_time": -1}, "bench_import.Import.time_numpy": {"code": "class Import:\n    def time_numpy(self):\n        self.execute('import numpy')", "min_run_count": 2, "name": "bench_import.Import.time_numpy", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5cb9a60ea63951e4ed5e53d18cbebb7b1ae313ae422ff739356454e6f9f2c5d7", "warmup_time": -1}, "bench_import.Import.time_numpy_inspect": {"code": "class Import:\n    def time_numpy_inspect(self):\n        # What are the savings from avoiding to import the inspect module?\n        self.execute('import numpy, inspect')", "min_run_count": 2, "name": "bench_import.Import.time_numpy_inspect", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3dd22ba8c1d5c49a9d99843d70d69a23add5d539d482ece58b85fe9cbfae98d2", "warmup_time": -1}, "bench_import.Import.time_random": {"code": "class Import:\n    def time_random(self):\n        self.execute('from numpy import random')", "min_run_count": 2, "name": "bench_import.Import.time_random", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "93e927c190a453a13a4dc57e51ad273e11e681bf788ef4051cf0b3a255837552", "warmup_time": -1}, "bench_indexing.Indexing.time_op": {"code": "class Indexing:\n    def time_op(self, indexes, sel, op):\n        self.func()\n\n    def setup(self, indexes, sel, op):\n        sel = sel.replace('I', indexes)\n    \n        ns = {'squares_': get_squares_(),\n              'np': np,\n              'indexes_': get_indexes_(),\n              'indexes_rand_': get_indexes_rand_()}\n    \n        code = \"def run():\\n    for a in squares_.values(): a[%s]%s\"\n        code = code % (sel, op)\n    \n        exec(code, ns)\n        self.func = ns['run']", "min_run_count": 2, "name": "bench_indexing.Indexing.time_op", "number": 0, "param_names": ["indexes", "sel", "op"], "params": [["'indexes_'", "'indexes_rand_'"], ["'I'", "':,I'", "'np.ix_(I, I)'"], ["''", "'=1'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2465b1e641afa0b484c5c37d765bbcf98df0cc9b75f502c64c2c79fa9e71b8b2", "warmup_time": -1}, "bench_indexing.IndexingSeparate.time_mmap_fancy_indexing": {"code": "class IndexingSeparate:\n    def time_mmap_fancy_indexing(self):\n        for i in range(1000):\n            self.fp[self.indexes]\n\n    def setup(self):\n        self.tmp_dir = mkdtemp()\n        self.fp = memmap(pjoin(self.tmp_dir, 'tmp.dat'),\n                         dtype=float32, mode='w+', shape=(50, 60))\n        self.indexes = array([3, 4, 6, 10, 20])", "min_run_count": 2, "name": "bench_indexing.IndexingSeparate.time_mmap_fancy_indexing", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d511fabf6c9d75bca8e0c77070a292a7498f23fd253bf151c2d0472028c8e375", "warmup_time": -1}, "bench_indexing.IndexingSeparate.time_mmap_slicing": {"code": "class IndexingSeparate:\n    def time_mmap_slicing(self):\n        for i in range(1000):\n            self.fp[5:10]\n\n    def setup(self):\n        self.tmp_dir = mkdtemp()\n        self.fp = memmap(pjoin(self.tmp_dir, 'tmp.dat'),\n                         dtype=float32, mode='w+', shape=(50, 60))\n        self.indexes = array([3, 4, 6, 10, 20])", "min_run_count": 2, "name": "bench_indexing.IndexingSeparate.time_mmap_slicing", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8aac8af758ba563381c8d021d9163a34a1652b3fcc129ec3555e9221a785b469", "warmup_time": -1}, "bench_indexing.IndexingStructured0D.time_array_all": {"code": "class IndexingStructured0D:\n    def time_array_all(self):\n        self.B['a'] = self.A['a']\n\n    def setup(self):\n        self.dt = np.dtype([('a', 'f4', 256)])\n    \n        self.A = np.zeros((), self.dt)\n        self.B = self.A.copy()\n    \n        self.a = np.zeros(1, self.dt)[0]\n        self.b = self.a.copy()", "min_run_count": 2, "name": "bench_indexing.IndexingStructured0D.time_array_all", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "972e93e84611a6e63b6d9fe5d2019b3b54f98452ed2b237b58f4d58bbde4072b", "warmup_time": -1}, "bench_indexing.IndexingStructured0D.time_array_slice": {"code": "class IndexingStructured0D:\n    def time_array_slice(self):\n        self.B['a'][:] = self.A['a']\n\n    def setup(self):\n        self.dt = np.dtype([('a', 'f4', 256)])\n    \n        self.A = np.zeros((), self.dt)\n        self.B = self.A.copy()\n    \n        self.a = np.zeros(1, self.dt)[0]\n        self.b = self.a.copy()", "min_run_count": 2, "name": "bench_indexing.IndexingStructured0D.time_array_slice", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7884c48afe99676d42705373c0678163cd9358c0af75b3888566a78b64b1a0ae", "warmup_time": -1}, "bench_indexing.IndexingStructured0D.time_scalar_all": {"code": "class IndexingStructured0D:\n    def time_scalar_all(self):\n        self.b['a'] = self.a['a']\n\n    def setup(self):\n        self.dt = np.dtype([('a', 'f4', 256)])\n    \n        self.A = np.zeros((), self.dt)\n        self.B = self.A.copy()\n    \n        self.a = np.zeros(1, self.dt)[0]\n        self.b = self.a.copy()", "min_run_count": 2, "name": "bench_indexing.IndexingStructured0D.time_scalar_all", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3379d09fc19f9b870f4e9a930bc98b6cda21f792cfb9caf37992752c1ed04c9e", "warmup_time": -1}, "bench_indexing.IndexingStructured0D.time_scalar_slice": {"code": "class IndexingStructured0D:\n    def time_scalar_slice(self):\n        self.b['a'][:] = self.a['a']\n\n    def setup(self):\n        self.dt = np.dtype([('a', 'f4', 256)])\n    \n        self.A = np.zeros((), self.dt)\n        self.B = self.A.copy()\n    \n        self.a = np.zeros(1, self.dt)[0]\n        self.b = self.a.copy()", "min_run_count": 2, "name": "bench_indexing.IndexingStructured0D.time_scalar_slice", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ffcfe894af4580d854b9e8b2d38687ab9ee9c372cc0d50fd467e5eab42e974ce", "warmup_time": -1}, "bench_indexing.ScalarIndexing.time_assign": {"code": "class ScalarIndexing:\n    def time_assign(self, ndim):\n        # time assignment from a python scalar\n        arr = self.array\n        indx = (1,) * ndim\n        for i in range(100):\n            arr[indx] = 5.\n\n    def setup(self, ndim):\n        self.array = np.ones((5,) * ndim)", "min_run_count": 2, "name": "bench_indexing.ScalarIndexing.time_assign", "number": 0, "param_names": ["ndim"], "params": [["0", "1", "2"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "52c0dfa579d132ce77b2ca2d0b042734f9d8f60d0e16ef2af7f292e1d49d5936", "warmup_time": -1}, "bench_indexing.ScalarIndexing.time_assign_cast": {"code": "class ScalarIndexing:\n    def time_assign_cast(self, ndim):\n        # time an assignment which may use a cast operation\n        arr = self.array\n        indx = (1,) * ndim\n        val = np.int16(43)\n        for i in range(100):\n            arr[indx] = val\n\n    def setup(self, ndim):\n        self.array = np.ones((5,) * ndim)", "min_run_count": 2, "name": "bench_indexing.ScalarIndexing.time_assign_cast", "number": 0, "param_names": ["ndim"], "params": [["0", "1", "2"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "36f3c671c5ba3cb5633f4a6b4e211938c2eb5857440c2a0e3c06281d2c0a5bc7", "warmup_time": -1}, "bench_indexing.ScalarIndexing.time_index": {"code": "class ScalarIndexing:\n    def time_index(self, ndim):\n        # time indexing.\n        arr = self.array\n        indx = (1,) * ndim\n        for i in range(100):\n            arr[indx]\n\n    def setup(self, ndim):\n        self.array = np.ones((5,) * ndim)", "min_run_count": 2, "name": "bench_indexing.ScalarIndexing.time_index", "number": 0, "param_names": ["ndim"], "params": [["0", "1", "2"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b5a4c10e3553e7101b7fc679cb355150c5b27d7c7b5544f50660fbe581936f73", "warmup_time": -1}, "bench_io.Copy.time_cont_assign": {"code": "class Copy:\n    def time_cont_assign(self, typename):\n        self.d[...] = 1\n\n    def setup(self, typename):\n        dtype = np.dtype(typename)\n        self.d = np.arange((50 * 500), dtype=dtype).reshape((500, 50))\n        self.e = np.arange((50 * 500), dtype=dtype).reshape((50, 500))\n        self.e_d = self.e.reshape(self.d.shape)\n        self.dflat = np.arange((50 * 500), dtype=dtype)", "min_run_count": 2, "name": "bench_io.Copy.time_cont_assign", "number": 0, "param_names": ["type"], "params": [["'int8'", "'int16'", "'float32'", "'float64'", "'complex64'", "'complex128'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "afe3edcb5a646c1dd3efa7d2b5084f3759d877cec053e46705ac093e8bafbddd", "warmup_time": -1}, "bench_io.Copy.time_memcpy": {"code": "class Copy:\n    def time_memcpy(self, typename):\n        self.d[...] = self.e_d\n\n    def setup(self, typename):\n        dtype = np.dtype(typename)\n        self.d = np.arange((50 * 500), dtype=dtype).reshape((500, 50))\n        self.e = np.arange((50 * 500), dtype=dtype).reshape((50, 500))\n        self.e_d = self.e.reshape(self.d.shape)\n        self.dflat = np.arange((50 * 500), dtype=dtype)", "min_run_count": 2, "name": "bench_io.Copy.time_memcpy", "number": 0, "param_names": ["type"], "params": [["'int8'", "'int16'", "'float32'", "'float64'", "'complex64'", "'complex128'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8e4099e96ab5221807bc0dd397733a0016f6f1bbbca8f5b800a8249a6e72bc7e", "warmup_time": -1}, "bench_io.Copy.time_memcpy_large_out_of_place": {"code": "class Copy:\n    def time_memcpy_large_out_of_place(self, typename):\n        l = np.ones(1024**2, dtype=np.dtype(typename))\n        l.copy()\n\n    def setup(self, typename):\n        dtype = np.dtype(typename)\n        self.d = np.arange((50 * 500), dtype=dtype).reshape((500, 50))\n        self.e = np.arange((50 * 500), dtype=dtype).reshape((50, 500))\n        self.e_d = self.e.reshape(self.d.shape)\n        self.dflat = np.arange((50 * 500), dtype=dtype)", "min_run_count": 2, "name": "bench_io.Copy.time_memcpy_large_out_of_place", "number": 0, "param_names": ["type"], "params": [["'int8'", "'int16'", "'float32'", "'float64'", "'complex64'", "'complex128'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "862a7ab3e90582f36eae4004c8ed717e47fc8e8fa042cf49b6c12a5df1d6b4c7", "warmup_time": -1}, "bench_io.Copy.time_strided_assign": {"code": "class Copy:\n    def time_strided_assign(self, typename):\n        self.dflat[::2] = 2\n\n    def setup(self, typename):\n        dtype = np.dtype(typename)\n        self.d = np.arange((50 * 500), dtype=dtype).reshape((500, 50))\n        self.e = np.arange((50 * 500), dtype=dtype).reshape((50, 500))\n        self.e_d = self.e.reshape(self.d.shape)\n        self.dflat = np.arange((50 * 500), dtype=dtype)", "min_run_count": 2, "name": "bench_io.Copy.time_strided_assign", "number": 0, "param_names": ["type"], "params": [["'int8'", "'int16'", "'float32'", "'float64'", "'complex64'", "'complex128'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "61d585e17292b3b6a8aba7775561f3fbffe991d8655b2335bfdbf1c83de99915", "warmup_time": -1}, "bench_io.Copy.time_strided_copy": {"code": "class Copy:\n    def time_strided_copy(self, typename):\n        self.d[...] = self.e.T\n\n    def setup(self, typename):\n        dtype = np.dtype(typename)\n        self.d = np.arange((50 * 500), dtype=dtype).reshape((500, 50))\n        self.e = np.arange((50 * 500), dtype=dtype).reshape((50, 500))\n        self.e_d = self.e.reshape(self.d.shape)\n        self.dflat = np.arange((50 * 500), dtype=dtype)", "min_run_count": 2, "name": "bench_io.Copy.time_strided_copy", "number": 0, "param_names": ["type"], "params": [["'int8'", "'int16'", "'float32'", "'float64'", "'complex64'", "'complex128'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e431dccc9dca8066e5245473c4aa724314bd94e7a7a5db466deb0e5cfcfab482", "warmup_time": -1}, "bench_io.CopyTo.time_copyto": {"code": "class CopyTo:\n    def time_copyto(self):\n        np.copyto(self.d, self.e)\n\n    def setup(self):\n        self.d = np.ones(50000)\n        self.e = self.d.copy()\n        self.m = (self.d == 1)\n        self.im = (~ self.m)\n        self.m8 = self.m.copy()\n        self.m8[::8] = (~ self.m[::8])\n        self.im8 = (~ self.m8)", "min_run_count": 2, "name": "bench_io.CopyTo.time_copyto", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "07950888132a0948b3c041b33f0f183b09ef914213babe934461be9b316d3221", "warmup_time": -1}, "bench_io.CopyTo.time_copyto_8_dense": {"code": "class CopyTo:\n    def time_copyto_8_dense(self):\n        np.copyto(self.d, self.e, where=self.im8)\n\n    def setup(self):\n        self.d = np.ones(50000)\n        self.e = self.d.copy()\n        self.m = (self.d == 1)\n        self.im = (~ self.m)\n        self.m8 = self.m.copy()\n        self.m8[::8] = (~ self.m[::8])\n        self.im8 = (~ self.m8)", "min_run_count": 2, "name": "bench_io.CopyTo.time_copyto_8_dense", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a73b9cc35e00d11b5cd0365076a62b7e2e3058a742abdac1ff0632af2afa63ce", "warmup_time": -1}, "bench_io.CopyTo.time_copyto_8_sparse": {"code": "class CopyTo:\n    def time_copyto_8_sparse(self):\n        np.copyto(self.d, self.e, where=self.m8)\n\n    def setup(self):\n        self.d = np.ones(50000)\n        self.e = self.d.copy()\n        self.m = (self.d == 1)\n        self.im = (~ self.m)\n        self.m8 = self.m.copy()\n        self.m8[::8] = (~ self.m[::8])\n        self.im8 = (~ self.m8)", "min_run_count": 2, "name": "bench_io.CopyTo.time_copyto_8_sparse", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6b3380a508d21032c997a83cb0f5f88e055d7c440b0e802e3856e0bba7b42699", "warmup_time": -1}, "bench_io.CopyTo.time_copyto_dense": {"code": "class CopyTo:\n    def time_copyto_dense(self):\n        np.copyto(self.d, self.e, where=self.im)\n\n    def setup(self):\n        self.d = np.ones(50000)\n        self.e = self.d.copy()\n        self.m = (self.d == 1)\n        self.im = (~ self.m)\n        self.m8 = self.m.copy()\n        self.m8[::8] = (~ self.m[::8])\n        self.im8 = (~ self.m8)", "min_run_count": 2, "name": "bench_io.CopyTo.time_copyto_dense", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3fc8f0ec8a3cbc2c0e6efed89c18560d81b4f3055eedac3e4cc6fb8f0ea88b6f", "warmup_time": -1}, "bench_io.CopyTo.time_copyto_sparse": {"code": "class CopyTo:\n    def time_copyto_sparse(self):\n        np.copyto(self.d, self.e, where=self.m)\n\n    def setup(self):\n        self.d = np.ones(50000)\n        self.e = self.d.copy()\n        self.m = (self.d == 1)\n        self.im = (~ self.m)\n        self.m8 = self.m.copy()\n        self.m8[::8] = (~ self.m[::8])\n        self.im8 = (~ self.m8)", "min_run_count": 2, "name": "bench_io.CopyTo.time_copyto_sparse", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8b3edb57c11fe88b4cb32c4a592531aad95d8749f99cdaa508ad926e7411faf0", "warmup_time": -1}, "bench_io.LoadtxtCSVComments.time_comment_loadtxt_csv": {"code": "class LoadtxtCSVComments:\n    def time_comment_loadtxt_csv(self, num_lines):\n        # benchmark handling of lines with comments\n        # when loading in from csv files\n    \n        # inspired by similar benchmark in pandas\n        # for read_csv\n    \n        # need to rewind StringIO object (unfortunately\n        # confounding timing result somewhat) for every\n        # call to timing test proper\n        np.loadtxt(self.data_comments,\n                   delimiter=',')\n        self.data_comments.seek(0)\n\n    def setup(self, num_lines):\n        data = ['1,2,3 # comment'] * num_lines\n        # unfortunately, timeit will only run setup()\n        # between repeat events, but not for iterations\n        # within repeats, so the StringIO object\n        # will have to be rewinded in the benchmark proper\n        self.data_comments = StringIO('\\n'.join(data))", "min_run_count": 2, "name": "bench_io.LoadtxtCSVComments.time_comment_loadtxt_csv", "number": 0, "param_names": ["num_lines"], "params": [["10", "100", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "527d34c15d3f59499d23933839e9ed2774a7d72f5720f961041d449fec6e75b1", "warmup_time": -1}, "bench_io.LoadtxtCSVDateTime.time_loadtxt_csv_datetime": {"code": "class LoadtxtCSVDateTime:\n    def time_loadtxt_csv_datetime(self, num_lines):\n        # rewind StringIO object -- the timing iterations\n        # are state-dependent\n        X = np.loadtxt(self.csv_data,\n                       delimiter=',',\n                       dtype=([('dates', 'M8[us]'),\n                               ('values', 'float64')]))\n        self.csv_data.seek(0)\n\n    def setup(self, num_lines):\n        # create the equivalent of a two-column CSV file\n        # with date strings in the first column and random\n        # floating point data in the second column\n        dates = np.arange('today', 20, dtype=np.datetime64)\n        np.random.seed(123)\n        values = np.random.rand(20)\n        date_line = ''\n    \n        for date, value in zip(dates, values):\n            date_line += (str(date) + ',' + str(value) + '\\n')\n    \n        # expand data to specified number of lines\n        data = date_line * (num_lines // 20)\n        self.csv_data = StringIO(data)", "min_run_count": 2, "name": "bench_io.LoadtxtCSVDateTime.time_loadtxt_csv_datetime", "number": 0, "param_names": ["num_lines"], "params": [["20", "200", "2000", "20000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ca4b6d747d9d6734cbb7bad3d6636c23bc828717f5c3cdc9bbc4011e4b2beaa2", "warmup_time": -1}, "bench_io.LoadtxtCSVSkipRows.time_skiprows_csv": {"code": "class LoadtxtCSVSkipRows:\n    def time_skiprows_csv(self, skiprows):\n        np.loadtxt(self.fname,\n                   delimiter=',',\n                   skiprows=skiprows)\n\n    def setup(self, skiprows):\n        np.random.seed(123)\n        test_array = np.random.rand(100000, 3)\n        self.fname = 'test_array.csv'\n        np.savetxt(fname=self.fname,\n                   X=test_array,\n                   delimiter=',')", "min_run_count": 2, "name": "bench_io.LoadtxtCSVSkipRows.time_skiprows_csv", "number": 0, "param_names": ["skiprows"], "params": [["0", "500", "10000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3e404fbe768ffacb38decdc20759baa4c49675a337db49def01ca2ad8ec05f2b", "warmup_time": -1}, "bench_io.LoadtxtCSVStructured.time_loadtxt_csv_struct_dtype": {"code": "class LoadtxtCSVStructured:\n    def time_loadtxt_csv_struct_dtype(self):\n        # obligate rewind of StringIO object\n        # between iterations of a repeat:\n    \n        np.loadtxt(self.csv_data,\n                   delimiter=',',\n                   dtype=[('category_1', 'S1'),\n                          ('category_2', 'i4'),\n                          ('category_3', 'f8'),\n                          ('category_4', 'S1'),\n                          ('category_5', 'f8')])\n        self.csv_data.seek(0)\n\n    def setup(self):\n        num_lines = 50000\n        data = [\"M, 21, 72, X, 155\"] * num_lines\n        self.csv_data = StringIO('\\n'.join(data))", "min_run_count": 2, "name": "bench_io.LoadtxtCSVStructured.time_loadtxt_csv_struct_dtype", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d236c8076ec7d1306b444fd6bfc435c8a78186c0d9c05ac68b7de4d9a9c48c93", "warmup_time": -1}, "bench_io.LoadtxtCSVdtypes.time_loadtxt_dtypes_csv": {"code": "class LoadtxtCSVdtypes:\n    def time_loadtxt_dtypes_csv(self, dtype, num_lines):\n        # benchmark loading arrays of various dtypes\n        # from csv files\n    \n        # state-dependent timing benchmark requires\n        # rewind of StringIO object\n    \n        np.loadtxt(self.csv_data,\n                   delimiter=',',\n                   dtype=dtype)\n        self.csv_data.seek(0)\n\n    def setup(self, dtype, num_lines):\n        data = ['5, 7, 888'] * num_lines\n        self.csv_data = StringIO('\\n'.join(data))", "min_run_count": 2, "name": "bench_io.LoadtxtCSVdtypes.time_loadtxt_dtypes_csv", "number": 0, "param_names": ["dtype", "num_lines"], "params": [["'float32'", "'float64'", "'int32'", "'int64'", "'complex128'", "'str'", "'object'"], ["10", "100", "10000", "100000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3b026040fb38600a75f663e806cea93f834736591f99756972d616f4f1f4ddfc", "warmup_time": -1}, "bench_io.LoadtxtReadUint64Integers.time_read_uint64": {"code": "class LoadtxtReadUint64Integers:\n    def time_read_uint64(self, size):\n        # mandatory rewind of StringIO object\n        # between iterations of a repeat:\n        np.loadtxt(self.data1)\n        self.data1.seek(0)\n\n    def setup(self, size):\n        arr = np.arange(size).astype('uint64') + 2**63\n        self.data1 = StringIO('\\n'.join(arr.astype(str).tolist()))\n        arr = arr.astype(object)\n        arr[500] = -1\n        self.data2 = StringIO('\\n'.join(arr.astype(str).tolist()))", "min_run_count": 2, "name": "bench_io.LoadtxtReadUint64Integers.time_read_uint64", "number": 0, "param_names": ["size"], "params": [["550", "1000", "10000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "adea3edd8d53ff3f6ba2a1d35bb9f07b8854d1559de84f52f770d3bce45acf19", "warmup_time": -1}, "bench_io.LoadtxtReadUint64Integers.time_read_uint64_neg_values": {"code": "class LoadtxtReadUint64Integers:\n    def time_read_uint64_neg_values(self, size):\n        # mandatory rewind of StringIO object\n        # between iterations of a repeat:\n        np.loadtxt(self.data2)\n        self.data2.seek(0)\n\n    def setup(self, size):\n        arr = np.arange(size).astype('uint64') + 2**63\n        self.data1 = StringIO('\\n'.join(arr.astype(str).tolist()))\n        arr = arr.astype(object)\n        arr[500] = -1\n        self.data2 = StringIO('\\n'.join(arr.astype(str).tolist()))", "min_run_count": 2, "name": "bench_io.LoadtxtReadUint64Integers.time_read_uint64_neg_values", "number": 0, "param_names": ["size"], "params": [["550", "1000", "10000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6a9872bc06310337a9284c05f6fc4454314ea78241afefc341c4fc9f283814bf", "warmup_time": -1}, "bench_io.LoadtxtUseColsCSV.time_loadtxt_usecols_csv": {"code": "class LoadtxtUseColsCSV:\n    def time_loadtxt_usecols_csv(self, usecols):\n        # must rewind StringIO because of state\n        # dependence of file reading\n        np.loadtxt(self.csv_data,\n                   delimiter=',',\n                   usecols=usecols)\n        self.csv_data.seek(0)\n\n    def setup(self, usecols):\n        num_lines = 5000\n        data = ['0, 1, 2, 3, 4, 5, 6, 7, 8, 9'] * num_lines\n        self.csv_data = StringIO('\\n'.join(data))", "min_run_count": 2, "name": "bench_io.LoadtxtUseColsCSV.time_loadtxt_usecols_csv", "number": 0, "param_names": ["usecols"], "params": [["2", "[1, 3]", "[1, 3, 5, 7]"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6767a50e078d8b82657e856649c176b41222e6097da66a4094631164a7579747", "warmup_time": -1}, "bench_io.Savez.time_vb_savez_squares": {"code": "class Savez:\n    def time_vb_savez_squares(self):\n        np.savez('tmp.npz', **self.squares)\n\n    def setup(self):\n        self.squares = get_squares()", "min_run_count": 2, "name": "bench_io.Savez.time_vb_savez_squares", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1d68d79f6ca00119e591c2cf1dd228713f70a6478358c985911a0c76299407b1", "warmup_time": -1}, "bench_itemselection.PutMask.time_dense": {"code": "class PutMask:\n    def time_dense(self, values_is_scalar, dtype):\n        np.putmask(self.arr, self.dense_mask, self.vals)\n\n    def setup(self, values_is_scalar, dtype):\n        if values_is_scalar:\n            self.vals = np.array(1., dtype=dtype)\n        else:\n            self.vals = np.ones(1000, dtype=dtype)\n    \n        self.arr = np.ones(1000, dtype=dtype)\n    \n        self.dense_mask = np.ones(1000, dtype=\"bool\")\n        self.sparse_mask = np.zeros(1000, dtype=\"bool\")", "min_run_count": 2, "name": "bench_itemselection.PutMask.time_dense", "number": 0, "param_names": ["values_is_scalar", "dtype"], "params": [["True", "False"], ["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "166dfab55086e824fc45c71ba79ed453e0de08edbd84c71a8b60468e93c27c89", "warmup_time": -1}, "bench_itemselection.PutMask.time_sparse": {"code": "class PutMask:\n    def time_sparse(self, values_is_scalar, dtype):\n        np.putmask(self.arr, self.sparse_mask, self.vals)\n\n    def setup(self, values_is_scalar, dtype):\n        if values_is_scalar:\n            self.vals = np.array(1., dtype=dtype)\n        else:\n            self.vals = np.ones(1000, dtype=dtype)\n    \n        self.arr = np.ones(1000, dtype=dtype)\n    \n        self.dense_mask = np.ones(1000, dtype=\"bool\")\n        self.sparse_mask = np.zeros(1000, dtype=\"bool\")", "min_run_count": 2, "name": "bench_itemselection.PutMask.time_sparse", "number": 0, "param_names": ["values_is_scalar", "dtype"], "params": [["True", "False"], ["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "dadc5e4b5b3dd8f832173b7b7e1f8efd82503d4238e6691b90e9969fd2828f9c", "warmup_time": -1}, "bench_itemselection.Take.time_contiguous": {"code": "class Take:\n    def time_contiguous(self, shape, mode, dtype):\n        self.arr.take(self.indices, axis=-2, mode=mode)\n\n    def setup(self, shape, mode, dtype):\n        self.arr = np.ones(shape, dtype)\n        self.indices = np.arange(1000)", "min_run_count": 2, "name": "bench_itemselection.Take.time_contiguous", "number": 0, "param_names": ["shape", "mode", "dtype"], "params": [["(1000, 1)", "(1000, 2)", "(2, 1000, 1)", "(1000, 3)"], ["'raise'", "'wrap'", "'clip'"], ["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "464749957650ef1727b83afc00207bcd11ac8a1d60cd0d9352c205b4cbab00d0", "warmup_time": -1}, "bench_lib.Isin.time_isin": {"code": "class Isin:\n    def time_isin(self, size, highest_element):\n        np.isin(self.array, self.in_array)\n\n    def setup(self, size, highest_element):\n        self.array = np.random.randint(\n                low=0, high=highest_element, size=size)\n        self.in_array = np.random.randint(\n                low=0, high=highest_element, size=size)", "min_run_count": 2, "name": "bench_lib.Isin.time_isin", "number": 0, "param_names": ["size", "highest_element"], "params": [["10", "100000", "3000000"], ["10", "10000", "100000000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "990e50d77ff5825f429cf0b636cbd867c11bde5228659384ea04bade0076637d", "warmup_time": -1}, "bench_lib.Nan.time_nanargmax": {"code": "class Nan:\n    def time_nanargmax(self, array_size, percent_nans):\n        np.nanargmax(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nanargmax", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e93b632ae2c175e9f074fecf982b2e75825933044e266a73e608882fb4106e39", "warmup_time": -1}, "bench_lib.Nan.time_nanargmin": {"code": "class Nan:\n    def time_nanargmin(self, array_size, percent_nans):\n        np.nanargmin(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nanargmin", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9385e2fafd18fc88d1b8c187b5fd6a41beaaa05dd04da8369310d0654de51fdb", "warmup_time": -1}, "bench_lib.Nan.time_nancumprod": {"code": "class Nan:\n    def time_nancumprod(self, array_size, percent_nans):\n        np.nancumprod(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nancumprod", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c5152de8ed506c6bac541397bf24900bfb9232cb7c700c57ab580655a16ef9a1", "warmup_time": -1}, "bench_lib.Nan.time_nancumsum": {"code": "class Nan:\n    def time_nancumsum(self, array_size, percent_nans):\n        np.nancumsum(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nancumsum", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c6f6d799b85c622c7182ea607d345bd1e58a57e0edb2c400d9addfaacbd83c0b", "warmup_time": -1}, "bench_lib.Nan.time_nanmax": {"code": "class Nan:\n    def time_nanmax(self, array_size, percent_nans):\n        np.nanmax(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nanmax", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "97743a24377113c2ba327e2bedf80ccd0eef0beb04bfd9ff0955fd171e91ed9e", "warmup_time": -1}, "bench_lib.Nan.time_nanmean": {"code": "class Nan:\n    def time_nanmean(self, array_size, percent_nans):\n        np.nanmean(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nanmean", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "17469b47e08e615431155eecb3988ad949edeed425d54d3250dbe73b4b1a8545", "warmup_time": -1}, "bench_lib.Nan.time_nanmedian": {"code": "class Nan:\n    def time_nanmedian(self, array_size, percent_nans):\n        np.nanmedian(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nanmedian", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0304fe4c2e9af7017d4850ddd0fbc5c0685194ae26169415a8fb3edc887120cb", "warmup_time": -1}, "bench_lib.Nan.time_nanmin": {"code": "class Nan:\n    def time_nanmin(self, array_size, percent_nans):\n        np.nanmin(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nanmin", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "422814a93a17c53f1fc66f2c0cf02bd469c610907711b4a88ec30afcca8a4f1a", "warmup_time": -1}, "bench_lib.Nan.time_nanpercentile": {"code": "class Nan:\n    def time_nanpercentile(self, array_size, percent_nans):\n        np.nanpercentile(self.arr, q=50)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nanpercentile", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "43b19dca34cc3d049c734b37fb526294d75cdae30fd6362dd1d25ee588029890", "warmup_time": -1}, "bench_lib.Nan.time_nanprod": {"code": "class Nan:\n    def time_nanprod(self, array_size, percent_nans):\n        np.nanprod(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nanprod", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "76f6ddee7a2bd922a811a590da914e871a9da441ace23f624f885eff2ced6dda", "warmup_time": -1}, "bench_lib.Nan.time_nanquantile": {"code": "class Nan:\n    def time_nanquantile(self, array_size, percent_nans):\n        np.nanquantile(self.arr, q=0.2)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nanquantile", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b6f9f81b2ba7ce0db3202f8e704563ef00acd142d57c08af0abae29275eb1887", "warmup_time": -1}, "bench_lib.Nan.time_nanstd": {"code": "class Nan:\n    def time_nanstd(self, array_size, percent_nans):\n        np.nanstd(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nanstd", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8b165d52bb3a1a20c40d491c8b58205b060401acb5cb2e98ad86e3280ae1fd8f", "warmup_time": -1}, "bench_lib.Nan.time_nansum": {"code": "class Nan:\n    def time_nansum(self, array_size, percent_nans):\n        np.nansum(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nansum", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "437765c3785e683bce0eb75c444aedb41352d0466d14fa89b112191fc4b4a0ec", "warmup_time": -1}, "bench_lib.Nan.time_nanvar": {"code": "class Nan:\n    def time_nanvar(self, array_size, percent_nans):\n        np.nanvar(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Nan.time_nanvar", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7a04b150fb7a516a6d80b5c4ddf17d050b765c19f7962e0c5e3d1931a694869f", "warmup_time": -1}, "bench_lib.Pad.time_pad": {"code": "class Pad:\n    def time_pad(self, shape, pad_width, mode):\n        np.pad(self.array, pad_width, mode)\n\n    def setup(self, shape, pad_width, mode):\n        # Make sure to fill the array to make the OS page fault\n        # in the setup phase and not the timed phase\n        self.array = np.full(shape, fill_value=1, dtype=np.float64)", "min_run_count": 2, "name": "bench_lib.Pad.time_pad", "number": 0, "param_names": ["shape", "pad_width", "mode"], "params": [["(4194304,)", "(1024, 1024)", "(256, 128, 1)", "(4, 4, 4, 4)", "(1, 1, 1, 1, 1)"], ["1", "8", "(0, 32)"], ["'constant'", "'edge'", "'linear_ramp'", "'mean'", "'reflect'", "'wrap'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b4277ec92e77c2bf4bb0b2a8e8dce9197194cef3f65e13f14bd7fb5b7e74a8ac", "warmup_time": -1}, "bench_lib.Unique.time_unique": {"code": "class Unique:\n    def time_unique(self, array_size, percent_nans):\n        np.unique(self.arr)\n\n    def setup(self, array_size, percent_nans):\n        np.random.seed(123)\n        # produce a randomly shuffled array with the\n        # approximate desired percentage np.nan content\n        base_array = np.random.uniform(size=array_size)\n        base_array[base_array < percent_nans / 100.] = np.nan\n        self.arr = base_array", "min_run_count": 2, "name": "bench_lib.Unique.time_unique", "number": 0, "param_names": ["array_size", "percent_nans"], "params": [["200", "200000"], ["0", "0.1", "2.0", "50.0", "90.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1decf0ff98fb6d5abc45236b819ffeb9c2dacb6aaa98ef6216f4ff307fdf042f", "warmup_time": -1}, "bench_linalg.Eindot.time_dot_a_b": {"code": "class Eindot:\n    def time_dot_a_b(self):\n        np.dot(self.a, self.b)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_dot_a_b", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "90f6bce9991a3ec6b21cdb7d7612044fe2ab4a6f4baa4d09ad9f1532ae1ed729", "warmup_time": -1}, "bench_linalg.Eindot.time_dot_d_dot_b_c": {"code": "class Eindot:\n    def time_dot_d_dot_b_c(self):\n        np.dot(self.d, np.dot(self.b, self.c))\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_dot_d_dot_b_c", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "bfab7b7d665b79c0d6cd60cdebb0069198b221c435e1376c860d9547ffed5a3b", "warmup_time": -1}, "bench_linalg.Eindot.time_dot_trans_a_at": {"code": "class Eindot:\n    def time_dot_trans_a_at(self):\n        np.dot(self.a, self.at)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_dot_trans_a_at", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5312f8c34eaec25db7229551b2d1b3a36a60967397e0d6c2a5f3dd2ef7c9da39", "warmup_time": -1}, "bench_linalg.Eindot.time_dot_trans_a_atc": {"code": "class Eindot:\n    def time_dot_trans_a_atc(self):\n        np.dot(self.a, self.atc)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_dot_trans_a_atc", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2aaf3ac46d4867f457064a7af0eb0bb69d2357840c425d21e2dca264654ab0e7", "warmup_time": -1}, "bench_linalg.Eindot.time_dot_trans_at_a": {"code": "class Eindot:\n    def time_dot_trans_at_a(self):\n        np.dot(self.at, self.a)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_dot_trans_at_a", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3f4eddebca7bb5be74255d929a51634b57aa16904159810bcf998c44c82852fc", "warmup_time": -1}, "bench_linalg.Eindot.time_dot_trans_atc_a": {"code": "class Eindot:\n    def time_dot_trans_atc_a(self):\n        np.dot(self.atc, self.a)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_dot_trans_atc_a", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "59ac3a40d150a1adaabb06fb254b4308c270e5cd305fb71a0422fc0d352fb0f6", "warmup_time": -1}, "bench_linalg.Eindot.time_einsum_i_ij_j": {"code": "class Eindot:\n    def time_einsum_i_ij_j(self):\n        np.einsum('i,ij,j', self.d, self.b, self.c)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_einsum_i_ij_j", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b1430a7cb033c76f16784f9e1ad22a1823dc42f09801eff4f508a03fa87a5894", "warmup_time": -1}, "bench_linalg.Eindot.time_einsum_ij_jk_a_b": {"code": "class Eindot:\n    def time_einsum_ij_jk_a_b(self):\n        np.einsum('ij,jk', self.a, self.b)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_einsum_ij_jk_a_b", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f59314fd417195a44f7811dc7866043d4ac947486c2065d5e76667cd3efd9b2a", "warmup_time": -1}, "bench_linalg.Eindot.time_einsum_ijk_jil_kl": {"code": "class Eindot:\n    def time_einsum_ijk_jil_kl(self):\n        np.einsum('ijk,jil->kl', self.a3, self.b3)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_einsum_ijk_jil_kl", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ca6de720148ca6468c9b96c0a584634bfd37611a176acf7aceb072a6b6d523a9", "warmup_time": -1}, "bench_linalg.Eindot.time_inner_trans_a_a": {"code": "class Eindot:\n    def time_inner_trans_a_a(self):\n        np.inner(self.a, self.a)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_inner_trans_a_a", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ff937aafce634b08b6e5a183252e02a459877dcfbfc6c7a2dc38a2a0bc2ec61f", "warmup_time": -1}, "bench_linalg.Eindot.time_inner_trans_a_ac": {"code": "class Eindot:\n    def time_inner_trans_a_ac(self):\n        np.inner(self.a, self.ac)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_inner_trans_a_ac", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "75be1a984676fcf27a3f71634783126016d5893ab4806f17cc8fc5b9dd0481ed", "warmup_time": -1}, "bench_linalg.Eindot.time_matmul_a_b": {"code": "class Eindot:\n    def time_matmul_a_b(self):\n        np.matmul(self.a, self.b)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_matmul_a_b", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8de65997a20d204169d458a6c8dbd028e175482b00a244e57bee527705d8049d", "warmup_time": -1}, "bench_linalg.Eindot.time_matmul_d_matmul_b_c": {"code": "class Eindot:\n    def time_matmul_d_matmul_b_c(self):\n        np.matmul(self.d, np.matmul(self.b, self.c))\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_matmul_d_matmul_b_c", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "29cf075642392ec27e0bf81b3c28ed75d0470a4c9180bbe2a32673affb49c2dd", "warmup_time": -1}, "bench_linalg.Eindot.time_matmul_trans_a_at": {"code": "class Eindot:\n    def time_matmul_trans_a_at(self):\n        np.matmul(self.a, self.at)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_matmul_trans_a_at", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e3c80942140f34f39e469517660d62496f439c0e2b4e8f1e21e0097af4ec25a9", "warmup_time": -1}, "bench_linalg.Eindot.time_matmul_trans_a_atc": {"code": "class Eindot:\n    def time_matmul_trans_a_atc(self):\n        np.matmul(self.a, self.atc)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_matmul_trans_a_atc", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "80227843461ad996deb3d17b6b0e1ffc84a639663196e31a9bb49846e9e72da6", "warmup_time": -1}, "bench_linalg.Eindot.time_matmul_trans_at_a": {"code": "class Eindot:\n    def time_matmul_trans_at_a(self):\n        np.matmul(self.at, self.a)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_matmul_trans_at_a", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b9ed64e91ad9ac7937d4064ed9c1f7a432c0df7b6f912e029126146d76493e97", "warmup_time": -1}, "bench_linalg.Eindot.time_matmul_trans_atc_a": {"code": "class Eindot:\n    def time_matmul_trans_atc_a(self):\n        np.matmul(self.atc, self.a)\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_matmul_trans_atc_a", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7d84f2dd41ff3b11ae8fbd1c920eeb5f02793f02d93e39fa84bcb2815ea1a9c1", "warmup_time": -1}, "bench_linalg.Eindot.time_tensordot_a_b_axes_1_0_0_1": {"code": "class Eindot:\n    def time_tensordot_a_b_axes_1_0_0_1(self):\n        np.tensordot(self.a3, self.b3, axes=([1, 0], [0, 1]))\n\n    def setup(self):\n        self.a = np.arange(60000.0).reshape(150, 400)\n        self.ac = self.a.copy()\n        self.at = self.a.T\n        self.atc = self.a.T.copy()\n        self.b = np.arange(240000.0).reshape(400, 600)\n        self.c = np.arange(600)\n        self.d = np.arange(400)\n    \n        self.a3 = np.arange(480000.).reshape(60, 80, 100)\n        self.b3 = np.arange(192000.).reshape(80, 60, 40)", "min_run_count": 2, "name": "bench_linalg.Eindot.time_tensordot_a_b_axes_1_0_0_1", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e0e115ed5626e3f37056c84484c86e35bc62234e7781a233afc1e6a00c19c8c5", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_contig_contig": {"code": "class Einsum:\n    def time_einsum_contig_contig(self, dtype):\n        np.einsum(\"ji,i->\", self.two_dim, self.one_dim_small, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_contig_contig", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9b2e0d4dd7dfaeb155d5e8e2a2e8c1251588d7b01ee3516f52568b463fc93a4a", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_contig_outstride0": {"code": "class Einsum:\n    def time_einsum_contig_outstride0(self, dtype):\n        np.einsum(\"i->\", self.one_dim_big, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_contig_outstride0", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "bb8130d3fbd4a5e6a764d4e7b8a4fb43755d9effddb88e8f5a594313037ba5f2", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_mul": {"code": "class Einsum:\n    def time_einsum_mul(self, dtype):\n        np.einsum(\"i,->i\", self.one_dim_big, 300, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_mul", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7ea3a259fec7835adfd4999597e8089f0ad6930240afd86c55234c3507d40f3d", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_multiply": {"code": "class Einsum:\n    def time_einsum_multiply(self, dtype):\n        np.einsum(\"..., ...\", self.two_dim_small, self.three_dim , optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_multiply", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6717702beca49a9692c90576a0de2dc6bd44ece1dfbe72ee1db40c975fb84334", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_noncon_contig_contig": {"code": "class Einsum:\n    def time_einsum_noncon_contig_contig(self, dtype):\n        np.einsum(\"ji,i->\", self.non_contiguous_dim2, self.non_contiguous_dim1_small, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_noncon_contig_contig", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c1c19b9c7475687eeec8ec7395078652f20d1b81df67a27ae4d56a249bd0c4dc", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_noncon_contig_outstride0": {"code": "class Einsum:\n    def time_einsum_noncon_contig_outstride0(self, dtype):\n        np.einsum(\"i->\", self.non_contiguous_dim1, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_noncon_contig_outstride0", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7e1af46b3ca1759abefc601375eeb17c1f9a66928faf80ab1674750c05a08d55", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_noncon_mul": {"code": "class Einsum:\n    def time_einsum_noncon_mul(self, dtype):\n        np.einsum(\"i,->i\", self.non_contiguous_dim1, 300, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_noncon_mul", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "dc6fa494deb5859afabf5b437b0cb6bf89502b82bea6bd7ad26309a50f63795d", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_noncon_multiply": {"code": "class Einsum:\n    def time_einsum_noncon_multiply(self, dtype):\n        np.einsum(\"..., ...\", self.non_contiguous_dim2, self.non_contiguous_dim3, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_noncon_multiply", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "708aed51ae78f6a4950611bac596611c2cef1ae3631f097f163b603c9246353e", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_noncon_outer": {"code": "class Einsum:\n    def time_einsum_noncon_outer(self, dtype):\n        np.einsum(\"i,j\", self.non_contiguous_dim1, self.non_contiguous_dim1, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_noncon_outer", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "35d4eb23507e04b92215a5d1158032df3aecee7069ecf0e3fbe29ecdd3ab0250", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_noncon_sum_mul": {"code": "class Einsum:\n    def time_einsum_noncon_sum_mul(self, dtype):\n        np.einsum(\",i...->\", 300, self.non_contiguous_dim3, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_noncon_sum_mul", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a7dbe071225b5f70a2807a439994cf93267a1b000b3eb363d695bb80c8ea301b", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_noncon_sum_mul2": {"code": "class Einsum:\n    def time_einsum_noncon_sum_mul2(self, dtype):\n        np.einsum(\"i...,->\", self.non_contiguous_dim3, 300, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_noncon_sum_mul2", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "77d0b9c3c76fb5caef7c9a3582248506a5ddeb4441b24b5b17d0ce8d0e3c7b29", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_outer": {"code": "class Einsum:\n    def time_einsum_outer(self, dtype):\n        np.einsum(\"i,j\", self.one_dim, self.one_dim, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_outer", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a8a86502ad000c5d2731d3c2ccf9598b583fb649610cc2dfa7b64262e7be0535", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_sum_mul": {"code": "class Einsum:\n    def time_einsum_sum_mul(self, dtype):\n        np.einsum(\",i...->\", 300, self.three_dim_small, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_sum_mul", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "96105fc32b45cbb62db555d225413907e032e52785de7d03d11a7c4be4982285", "warmup_time": -1}, "bench_linalg.Einsum.time_einsum_sum_mul2": {"code": "class Einsum:\n    def time_einsum_sum_mul2(self, dtype):\n        np.einsum(\"i...,->\", self.three_dim_small, 300, optimize=True)\n\n    def setup(self, dtype):\n        self.one_dim_small = np.arange(600, dtype=dtype)\n        self.one_dim = np.arange(3000, dtype=dtype)\n        self.one_dim_big = np.arange(480000, dtype=dtype)\n        self.two_dim_small = np.arange(1200, dtype=dtype).reshape(30, 40)\n        self.two_dim = np.arange(240000, dtype=dtype).reshape(400, 600)\n        self.three_dim_small = np.arange(10000, dtype=dtype).reshape(10,100,10)\n        self.three_dim = np.arange(24000, dtype=dtype).reshape(20, 30, 40)\n        # non_contiguous arrays\n        self.non_contiguous_dim1_small = np.arange(1, 80, 2, dtype=dtype)\n        self.non_contiguous_dim1 = np.arange(1, 4000, 2, dtype=dtype)\n        self.non_contiguous_dim2 = np.arange(1, 2400, 2, dtype=dtype).reshape(30, 40)\n        self.non_contiguous_dim3 = np.arange(1, 48000, 2, dtype=dtype).reshape(20, 30, 40)", "min_run_count": 2, "name": "bench_linalg.Einsum.time_einsum_sum_mul2", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "076a7807f4e1dc42b1ded2434fb533fc5d625f5c69708ee7ab83e27e5a2a184d", "warmup_time": -1}, "bench_linalg.Linalg.time_op": {"code": "class Linalg:\n    def time_op(self, op, typename):\n        self.func(self.a)\n\n    def setup(self, op, typename):\n        np.seterr(all='ignore')\n    \n        self.func = getattr(np.linalg, op)\n    \n        if op == 'cholesky':\n            # we need a positive definite\n            self.a = np.dot(get_squares_()[typename],\n                            get_squares_()[typename].T)\n        else:\n            self.a = get_squares_()[typename]\n    \n        # check that dtype is supported at all\n        try:\n            self.func(self.a[:2, :2])\n        except TypeError as e:\n            raise NotImplementedError() from e", "min_run_count": 2, "name": "bench_linalg.Linalg.time_op", "number": 0, "param_names": ["op", "type"], "params": [["'svd'", "'pinv'", "'det'", "'norm'"], ["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ec96fb5a1e3cb3d3b9f7942ee8998339851dfeb014b07775259423d500861162", "warmup_time": -1}, "bench_linalg.LinalgSmallArrays.time_det_small_array": {"code": "class LinalgSmallArrays:\n    def time_det_small_array(self):\n        np.linalg.det(self.array_5_5)\n\n    def setup(self):\n        self.array_5 = np.arange(5.)\n        self.array_5_5 = np.arange(5.)", "min_run_count": 2, "name": "bench_linalg.LinalgSmallArrays.time_det_small_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9c6fff8ce3ab8b5134357fefabe305a3a05e739d4c943fa213c5b1f4014d28cb", "warmup_time": -1}, "bench_linalg.LinalgSmallArrays.time_norm_small_array": {"code": "class LinalgSmallArrays:\n    def time_norm_small_array(self):\n        np.linalg.norm(self.array_5)\n\n    def setup(self):\n        self.array_5 = np.arange(5.)\n        self.array_5_5 = np.arange(5.)", "min_run_count": 2, "name": "bench_linalg.LinalgSmallArrays.time_norm_small_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4620b694e36ba5f2bc7bc29ceec4722f0a25c867fe933c5b5928b8361adc10df", "warmup_time": -1}, "bench_linalg.Lstsq.time_numpy_linalg_lstsq_a__b_float64": {"code": "class Lstsq:\n    def time_numpy_linalg_lstsq_a__b_float64(self):\n        np.linalg.lstsq(self.a, self.b, rcond=-1)\n\n    def setup(self):\n        self.a = get_squares_()['float64']\n        self.b = get_indexes_rand()[:100].astype(np.float64)", "min_run_count": 2, "name": "bench_linalg.Lstsq.time_numpy_linalg_lstsq_a__b_float64", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8986b54baed47d44faf78455a011ab17ccdfb51cc62cf0e48087f054a52c29e6", "warmup_time": -1}, "bench_ma.Concatenate.time_it": {"code": "class Concatenate:\n    def time_it(self, mode, n):\n        np.ma.concatenate(self.args)\n\n    def setup(self, mode, n):\n        # avoid np.zeros's lazy allocation that cause page faults during benchmark.\n        # np.fill will cause pagefaults to happen during setup.\n        normal = np.full((n, n), 0, int)\n        unmasked = np.ma.zeros((n, n), int)\n        masked = np.ma.array(normal, mask=True)\n    \n        mode_parts = mode.split('+')\n        base = mode_parts[0]\n        promote = 'masked' in mode_parts[1:]\n    \n        if base == 'ndarray':\n            args = 10 * (normal,)\n        elif base == 'unmasked':\n            args = 10 * (unmasked,)\n        else:\n            args = 10 * (masked,)\n    \n        if promote:\n            args = args[:-1] + (masked,)\n    \n        self.args = args", "min_run_count": 2, "name": "bench_ma.Concatenate.time_it", "number": 0, "param_names": ["mode", "n"], "params": [["'ndarray'", "'unmasked'", "'ndarray+masked'", "'unmasked+masked'", "'masked'"], ["2", "100", "2000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c5266b41dad24011ae7e64de9ff53d788ddeb5d55cbb4cff451dc49af0c70298", "warmup_time": -1}, "bench_ma.Indexing.time_0d": {"code": "class Indexing:\n    def time_0d(self, masked, ndim, size):\n        self.m[self.idx_0d]\n\n    def setup(self, masked, ndim, size):\n        x = np.arange(size**ndim).reshape(ndim * (size,))\n    \n        if masked:\n            self.m = np.ma.array(x, mask=x%2 == 0)\n        else:\n            self.m = np.ma.array(x)\n    \n        self.idx_scalar = (size//2,) * ndim\n        self.idx_0d = (size//2,) * ndim + (Ellipsis,)\n        self.idx_1d = (size//2,) * (ndim - 1)", "min_run_count": 2, "name": "bench_ma.Indexing.time_0d", "number": 0, "param_names": ["masked", "ndim", "size"], "params": [["True", "False"], ["1", "2"], ["10", "100", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3af17398e826ce96894f8d9e3df13390b6057d8ab4646cccf3dafe3a6b530dea", "warmup_time": -1}, "bench_ma.Indexing.time_1d": {"code": "class Indexing:\n    def time_1d(self, masked, ndim, size):\n        self.m[self.idx_1d]\n\n    def setup(self, masked, ndim, size):\n        x = np.arange(size**ndim).reshape(ndim * (size,))\n    \n        if masked:\n            self.m = np.ma.array(x, mask=x%2 == 0)\n        else:\n            self.m = np.ma.array(x)\n    \n        self.idx_scalar = (size//2,) * ndim\n        self.idx_0d = (size//2,) * ndim + (Ellipsis,)\n        self.idx_1d = (size//2,) * (ndim - 1)", "min_run_count": 2, "name": "bench_ma.Indexing.time_1d", "number": 0, "param_names": ["masked", "ndim", "size"], "params": [["True", "False"], ["1", "2"], ["10", "100", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2dc73766d9324469077751387174000e90cd198310ae5d0b5bbfbe2b3a0b1d55", "warmup_time": -1}, "bench_ma.Indexing.time_scalar": {"code": "class Indexing:\n    def time_scalar(self, masked, ndim, size):\n        self.m[self.idx_scalar]\n\n    def setup(self, masked, ndim, size):\n        x = np.arange(size**ndim).reshape(ndim * (size,))\n    \n        if masked:\n            self.m = np.ma.array(x, mask=x%2 == 0)\n        else:\n            self.m = np.ma.array(x)\n    \n        self.idx_scalar = (size//2,) * ndim\n        self.idx_0d = (size//2,) * ndim + (Ellipsis,)\n        self.idx_1d = (size//2,) * (ndim - 1)", "min_run_count": 2, "name": "bench_ma.Indexing.time_scalar", "number": 0, "param_names": ["masked", "ndim", "size"], "params": [["True", "False"], ["1", "2"], ["10", "100", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "20842912a6d684f5d66c15e2ef6fc5994066b617ff4c673efb382b98bd70c190", "warmup_time": -1}, "bench_ma.MA.time_masked_array": {"code": "class MA:\n    def time_masked_array(self):\n        np.ma.masked_array()\n\n    def setup(self):\n        self.l100 = range(100)\n        self.t100 = ([True] * 100)", "min_run_count": 2, "name": "bench_ma.MA.time_masked_array", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "569cb888c6b874c3b64957cab882b3e04f2d830d4581ce6aed29c758d2c32fa2", "warmup_time": -1}, "bench_ma.MA.time_masked_array_l100": {"code": "class MA:\n    def time_masked_array_l100(self):\n        np.ma.masked_array(self.l100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.t100 = ([True] * 100)", "min_run_count": 2, "name": "bench_ma.MA.time_masked_array_l100", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1bd9f2518b045c4e7f662bb4528b56e49605d20fd412c8657d0ef38741838eb5", "warmup_time": -1}, "bench_ma.MA.time_masked_array_l100_t100": {"code": "class MA:\n    def time_masked_array_l100_t100(self):\n        np.ma.masked_array(self.l100, self.t100)\n\n    def setup(self):\n        self.l100 = range(100)\n        self.t100 = ([True] * 100)", "min_run_count": 2, "name": "bench_ma.MA.time_masked_array_l100_t100", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5756fb2ab73509c5b839cd02f3317b36da59fd9b3eee66bad94c4cde42a86bb9", "warmup_time": -1}, "bench_ma.MACreation.time_ma_creations": {"code": "class MACreation:\n    def time_ma_creations(self, data, mask):\n        np.ma.array(data=np.zeros(int(data)), mask=mask)", "min_run_count": 2, "name": "bench_ma.MACreation.time_ma_creations", "number": 0, "param_names": ["data", "mask"], "params": [["10", "100", "1000"], ["True", "False", "None"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f966133729a78c368cf8654583f0f34111133f917bacae4bdce48de99b241b0b", "warmup_time": -1}, "bench_ma.MAFunctions1v.time_functions_1v": {"code": "class MAFunctions1v:\n    def time_functions_1v(self, mtype, func, msize):\n        # fun = {'np.ma.sin': np.ma.sin, 'np.sin': np.sin}[func]\n        fun = eval(f\"{mtype}.{func}\")\n        if msize == 'small':\n            fun(self.nmxs)\n        elif msize == 'big':\n            fun(self.nmxl)\n\n    def setup(self, mtype, func, msize):\n        xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        xl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 0.8\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmxl = np.ma.array(xl, mask=maskx)", "min_run_count": 2, "name": "bench_ma.MAFunctions1v.time_functions_1v", "number": 0, "param_names": ["mtype", "func", "msize"], "params": [["'np'", "'np.ma'"], ["'sin'", "'log'", "'sqrt'"], ["'small'", "'big'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "24b3575794742c897ac83d4a46b7e801584a3c4c9ee27a54087d887eeb4ed86b", "warmup_time": -1}, "bench_ma.MAFunctions2v.time_functions_2v": {"code": "class MAFunctions2v:\n    def time_functions_2v(self, mtype, func, msize):\n        fun = eval(f\"{mtype}.{func}\")\n        if msize == 'small':\n            fun(self.nmxs, self.nmys)\n        elif msize == 'big':\n            fun(self.nmxl, self.nmyl)\n\n    def setup(self, mtype, func, msize):\n        # Small arrays\n        xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        ys = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        m2 = [[True, False, True], [False, False, True]]\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmys = np.ma.array(ys, mask=m2)\n        # Big arrays\n        xl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        yl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 0.8\n        masky = yl < -0.8\n        self.nmxl = np.ma.array(xl, mask=maskx)\n        self.nmyl = np.ma.array(yl, mask=masky)", "min_run_count": 2, "name": "bench_ma.MAFunctions2v.time_functions_2v", "number": 0, "param_names": ["mtype", "func", "msize"], "params": [["'np'", "'np.ma'"], ["'multiply'", "'divide'", "'power'"], ["'small'", "'big'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "755034b97c46c09b62f150439c0829f960acd519d7c704beca2ebac7f80410bf", "warmup_time": -1}, "bench_ma.MAMethod0v.time_methods_0v": {"code": "class MAMethod0v:\n    def time_methods_0v(self, method, msize):\n        if msize == 'small':\n            mdat = self.nmxs\n        elif msize == 'big':\n            mdat = self.nmxl\n        getattr(mdat, method)()\n\n    def setup(self, method, msize):\n        xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        xl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 0.8\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmxl = np.ma.array(xl, mask=maskx)", "min_run_count": 2, "name": "bench_ma.MAMethod0v.time_methods_0v", "number": 0, "param_names": ["method", "msize"], "params": [["'ravel'", "'transpose'", "'compressed'", "'conjugate'"], ["'small'", "'big'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ee2083ba8d5890db5c0b2f1e8169febf905441c816951937af4d13363d278c00", "warmup_time": -1}, "bench_ma.MAMethodGetItem.time_methods_getitem": {"code": "class MAMethodGetItem:\n    def time_methods_getitem(self, margs, msize):\n        if msize == 'small':\n            mdat = self.nmxs\n        elif msize == 'big':\n            mdat = self.nmxl\n        getattr(mdat, '__getitem__')(margs)\n\n    def setup(self, margs, msize):\n        xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        xl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 0.8\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmxl = np.ma.array(xl, mask=maskx)", "min_run_count": 2, "name": "bench_ma.MAMethodGetItem.time_methods_getitem", "number": 0, "param_names": ["margs", "msize"], "params": [["0", "(0, 0)", "[0, -1]"], ["'small'", "'big'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6ed77716301f0f917a324f47f7c2d269e01eda132efeefe8c801e599e67dc49d", "warmup_time": -1}, "bench_ma.MAMethodSetItem.time_methods_setitem": {"code": "class MAMethodSetItem:\n    def time_methods_setitem(self, margs, mset, msize):\n        if msize == 'small':\n            mdat = self.nmxs\n        elif msize == 'big':\n            mdat = self.nmxl\n        getattr(mdat, '__setitem__')(margs, mset)\n\n    def setup(self, margs, mset, msize):\n        xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        xl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 0.8\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmxl = np.ma.array(xl, mask=maskx)", "min_run_count": 2, "name": "bench_ma.MAMethodSetItem.time_methods_setitem", "number": 0, "param_names": ["margs", "mset", "msize"], "params": [["0", "(0, 0)", "(-1, 0)"], ["17", "masked"], ["'small'", "'big'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8d4eb0f47f769df3bd5946b902a31618b0b55c5ccf615af52c895911e6eca776", "warmup_time": -1}, "bench_ma.UFunc.time_1d": {"code": "class UFunc:\n    def time_1d(self, a_masked, b_masked, size):\n        np.ma.add(self.a_1d, self.b_1d)\n\n    def setup(self, a_masked, b_masked, size):\n        x = np.arange(size).astype(np.uint8)\n    \n        self.a_scalar = np.ma.masked if a_masked else 5\n        self.b_scalar = np.ma.masked if b_masked else 3\n    \n        self.a_1d = np.ma.array(x, mask=x%2 == 0 if a_masked else np.ma.nomask)\n        self.b_1d = np.ma.array(x, mask=x%3 == 0 if b_masked else np.ma.nomask)\n    \n        self.a_2d = self.a_1d.reshape(1, -1)\n        self.b_2d = self.a_1d.reshape(-1, 1)", "min_run_count": 2, "name": "bench_ma.UFunc.time_1d", "number": 0, "param_names": ["a_masked", "b_masked", "size"], "params": [["True", "False"], ["True", "False"], ["10", "100", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3367abb12ea2e83d13287419c09a5fcfdec21cb8b976041105622e5f2455219a", "warmup_time": -1}, "bench_ma.UFunc.time_2d": {"code": "class UFunc:\n    def time_2d(self, a_masked, b_masked, size):\n        # broadcasting happens this time\n        np.ma.add(self.a_2d, self.b_2d)\n\n    def setup(self, a_masked, b_masked, size):\n        x = np.arange(size).astype(np.uint8)\n    \n        self.a_scalar = np.ma.masked if a_masked else 5\n        self.b_scalar = np.ma.masked if b_masked else 3\n    \n        self.a_1d = np.ma.array(x, mask=x%2 == 0 if a_masked else np.ma.nomask)\n        self.b_1d = np.ma.array(x, mask=x%3 == 0 if b_masked else np.ma.nomask)\n    \n        self.a_2d = self.a_1d.reshape(1, -1)\n        self.b_2d = self.a_1d.reshape(-1, 1)", "min_run_count": 2, "name": "bench_ma.UFunc.time_2d", "number": 0, "param_names": ["a_masked", "b_masked", "size"], "params": [["True", "False"], ["True", "False"], ["10", "100", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2f6eefd233384bed94c580db5fcefc09e11a86f0008ccf16cbf1dff95b0b9c23", "warmup_time": -1}, "bench_ma.UFunc.time_scalar": {"code": "class UFunc:\n    def time_scalar(self, a_masked, b_masked, size):\n        np.ma.add(self.a_scalar, self.b_scalar)\n\n    def setup(self, a_masked, b_masked, size):\n        x = np.arange(size).astype(np.uint8)\n    \n        self.a_scalar = np.ma.masked if a_masked else 5\n        self.b_scalar = np.ma.masked if b_masked else 3\n    \n        self.a_1d = np.ma.array(x, mask=x%2 == 0 if a_masked else np.ma.nomask)\n        self.b_1d = np.ma.array(x, mask=x%3 == 0 if b_masked else np.ma.nomask)\n    \n        self.a_2d = self.a_1d.reshape(1, -1)\n        self.b_2d = self.a_1d.reshape(-1, 1)", "min_run_count": 2, "name": "bench_ma.UFunc.time_scalar", "number": 0, "param_names": ["a_masked", "b_masked", "size"], "params": [["True", "False"], ["True", "False"], ["10", "100", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4496f86f82cad9053c558f7f3b1f7a8ad9ccd4d18b3a7d5dd2e0dd1192c8e4d9", "warmup_time": -1}, "bench_ma.UFunc.time_scalar_1d": {"code": "class UFunc:\n    def time_scalar_1d(self, a_masked, b_masked, size):\n        np.ma.add(self.a_scalar, self.b_1d)\n\n    def setup(self, a_masked, b_masked, size):\n        x = np.arange(size).astype(np.uint8)\n    \n        self.a_scalar = np.ma.masked if a_masked else 5\n        self.b_scalar = np.ma.masked if b_masked else 3\n    \n        self.a_1d = np.ma.array(x, mask=x%2 == 0 if a_masked else np.ma.nomask)\n        self.b_1d = np.ma.array(x, mask=x%3 == 0 if b_masked else np.ma.nomask)\n    \n        self.a_2d = self.a_1d.reshape(1, -1)\n        self.b_2d = self.a_1d.reshape(-1, 1)", "min_run_count": 2, "name": "bench_ma.UFunc.time_scalar_1d", "number": 0, "param_names": ["a_masked", "b_masked", "size"], "params": [["True", "False"], ["True", "False"], ["10", "100", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "98dfb3a1d0e42b2006cb34ac1dde59953825c9fbf5f1d3685a4ca3127525adc6", "warmup_time": -1}, "bench_ma.Where.time_where": {"code": "class Where:\n    def time_where(self, mtype, msize):\n        fun = eval(f\"{mtype}.where\")\n        if msize == 'small':\n            fun(self.nmxs > 2, self.nmxs, self.nmys)\n        elif msize == 'big':\n            fun(self.nmxl > 2, self.nmxl, self.nmyl)\n\n    def setup(self, mtype, msize):\n        # Small arrays\n        xs = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        ys = np.random.uniform(-1, 1, 6).reshape(2, 3)\n        m1 = [[True, False, False], [False, False, True]]\n        m2 = [[True, False, True], [False, False, True]]\n        self.nmxs = np.ma.array(xs, mask=m1)\n        self.nmys = np.ma.array(ys, mask=m2)\n        # Big arrays\n        xl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        yl = np.random.uniform(-1, 1, 100*100).reshape(100, 100)\n        maskx = xl > 0.8\n        masky = yl < -0.8\n        self.nmxl = np.ma.array(xl, mask=maskx)\n        self.nmyl = np.ma.array(yl, mask=masky)", "min_run_count": 2, "name": "bench_ma.Where.time_where", "number": 0, "param_names": ["mtype", "msize"], "params": [["'np'", "'np.ma'"], ["'small'", "'big'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5b7b290076b801337934489edd30be7c1d0437b0db2586612d854e73e08ce173", "warmup_time": -1}, "bench_overrides.ArrayFunction.time_mock_broadcast_to_duck": {"code": "class ArrayFunction:\n    def time_mock_broadcast_to_duck(self):\n        mock_broadcast_to(self.duck_array, ())\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]", "min_run_count": 2, "name": "bench_overrides.ArrayFunction.time_mock_broadcast_to_duck", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b54211444ccedb1ab418dbbf6ec0f6a2ef4262f33dff86946a325e943e80ba0e", "warmup_time": -1}, "bench_overrides.ArrayFunction.time_mock_broadcast_to_numpy": {"code": "class ArrayFunction:\n    def time_mock_broadcast_to_numpy(self):\n        mock_broadcast_to(self.numpy_array, ())\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]", "min_run_count": 2, "name": "bench_overrides.ArrayFunction.time_mock_broadcast_to_numpy", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a77448f26c942ff1b0caa4cfa8e496e7f3b84342a4b3b798fadfde02460e4a7a", "warmup_time": -1}, "bench_overrides.ArrayFunction.time_mock_concatenate_duck": {"code": "class ArrayFunction:\n    def time_mock_concatenate_duck(self):\n        mock_concatenate(self.duck_arrays, axis=0)\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]", "min_run_count": 2, "name": "bench_overrides.ArrayFunction.time_mock_concatenate_duck", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ca0f8a5a984c328b123d685cd3abebcfe69e74236884e9ae936604992f36247a", "warmup_time": -1}, "bench_overrides.ArrayFunction.time_mock_concatenate_many": {"code": "class ArrayFunction:\n    def time_mock_concatenate_many(self):\n        mock_concatenate(self.many_arrays, axis=0)\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]", "min_run_count": 2, "name": "bench_overrides.ArrayFunction.time_mock_concatenate_many", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d63644407e7bb0c62ecd497191be5179221a5471d2679821ab9cd51e58e33b81", "warmup_time": -1}, "bench_overrides.ArrayFunction.time_mock_concatenate_mixed": {"code": "class ArrayFunction:\n    def time_mock_concatenate_mixed(self):\n        mock_concatenate(self.mixed_arrays, axis=0)\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]", "min_run_count": 2, "name": "bench_overrides.ArrayFunction.time_mock_concatenate_mixed", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f0f836ffe9cd3cd7558defd3fcf150b87fed04847e82126cb3d0be71cf1db5d0", "warmup_time": -1}, "bench_overrides.ArrayFunction.time_mock_concatenate_numpy": {"code": "class ArrayFunction:\n    def time_mock_concatenate_numpy(self):\n        mock_concatenate(self.numpy_arrays, axis=0)\n\n    def setup(self):\n        self.numpy_array = np.array(1)\n        self.numpy_arrays = [np.array(1), np.array(2)]\n        self.many_arrays = 500 * self.numpy_arrays\n        self.duck_array = DuckArray()\n        self.duck_arrays = [DuckArray(), DuckArray()]\n        self.mixed_arrays = [np.array(1), DuckArray()]", "min_run_count": 2, "name": "bench_overrides.ArrayFunction.time_mock_concatenate_numpy", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ba531ff260ae0e34362db5e75dc2787f752347a622d2ac57279a05124ea3c43a", "warmup_time": -1}, "bench_random.Bounded.time_bounded": {"code": "class Bounded:\n    def time_bounded(self, bitgen, args):\n            \"\"\"\n            Timer for 8-bit bounded values.\n    \n            Parameters (packed as args)\n            ----------\n            dt : {uint8, uint16, uint32, unit64}\n                output dtype\n            max : int\n                Upper bound for range. Lower is always 0.  Must be <= 2**bits.\n            \"\"\"\n            dt, max = args\n            if bitgen == 'numpy':\n                self.rg.randint(0, max + 1, nom_size, dtype=dt)\n            else:\n                self.rg.integers(0, max + 1, nom_size, dtype=dt)\n\n    def setup(self, bitgen, args):\n        if bitgen == 'numpy':\n            self.rg = np.random.RandomState()\n        else:\n            self.rg = Generator(getattr(np.random, bitgen)())\n        self.rg.random()", "min_run_count": 2, "name": "bench_random.Bounded.time_bounded", "number": 0, "param_names": ["rng", "dt_max"], "params": [["'PCG64'", "'MT19937'", "'Philox'", "'SFC64'", "'numpy'"], ["[<class 'numpy.uint8'>, 95]", "[<class 'numpy.uint8'>, 64]", "[<class 'numpy.uint8'>, 127]", "[<class 'numpy.uint16'>, 95]", "[<class 'numpy.uint16'>, 1024]", "[<class 'numpy.uint16'>, 1535]", "[<class 'numpy.uint16'>, 2047]", "[<class 'numpy.uint32'>, 1024]", "[<class 'numpy.uint32'>, 1535]", "[<class 'numpy.uint32'>, 2047]", "[<class 'numpy.uint64'>, 95]", "[<class 'numpy.uint64'>, 1024]", "[<class 'numpy.uint64'>, 1535]", "[<class 'numpy.uint64'>, 2047]"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1976966bc3e0f289c56524699eb45b095dab1d74806707d5e3e40f3165b1aa29", "warmup_time": -1}, "bench_random.Choice.time_choice": {"code": "class Choice:\n    def time_choice(self, v):\n        self.rng.choice(self.a, 1000, replace=False)\n\n    def setup(self, v):\n        self.a = np.arange(v)\n        self.rng = np.random.default_rng()", "min_run_count": 2, "name": "bench_random.Choice.time_choice", "number": 0, "param_names": ["param1"], "params": [["1000.0", "1000000.0", "100000000.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "732a2a02157fac586fed5ed7e5cb87b3f922e3ee957fac07cc8a392d51f1e462", "warmup_time": -1}, "bench_random.Choice.time_legacy_choice": {"code": "class Choice:\n    def time_legacy_choice(self, v):\n        np.random.choice(self.a, 1000, replace=False)\n\n    def setup(self, v):\n        self.a = np.arange(v)\n        self.rng = np.random.default_rng()", "min_run_count": 2, "name": "bench_random.Choice.time_legacy_choice", "number": 0, "param_names": ["param1"], "params": [["1000.0", "1000000.0", "100000000.0"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f8ea1e2859fc2421cf7aafc0c6f30d0342781a578958dbadfeeb1cfc31cf6cf1", "warmup_time": -1}, "bench_random.Permutation.time_permutation_1d": {"code": "class Permutation:\n    def time_permutation_1d(self):\n        np.random.permutation(self.a_1d)\n\n    def setup(self):\n        self.n = 10000\n        self.a_1d = np.random.random(self.n)\n        self.a_2d = np.random.random((self.n, 2))", "min_run_count": 2, "name": "bench_random.Permutation.time_permutation_1d", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "551dd96381ce6ea1af2f4261ae7b78bb04024222f86e42dc477bced10c5d3326", "warmup_time": -1}, "bench_random.Permutation.time_permutation_2d": {"code": "class Permutation:\n    def time_permutation_2d(self):\n        np.random.permutation(self.a_2d)\n\n    def setup(self):\n        self.n = 10000\n        self.a_1d = np.random.random(self.n)\n        self.a_2d = np.random.random((self.n, 2))", "min_run_count": 2, "name": "bench_random.Permutation.time_permutation_2d", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "afbad8cd57abad2c145db591d5d673799f4702d837eb9c1fa2f69c5c853fe526", "warmup_time": -1}, "bench_random.Permutation.time_permutation_int": {"code": "class Permutation:\n    def time_permutation_int(self):\n        np.random.permutation(self.n)\n\n    def setup(self):\n        self.n = 10000\n        self.a_1d = np.random.random(self.n)\n        self.a_2d = np.random.random((self.n, 2))", "min_run_count": 2, "name": "bench_random.Permutation.time_permutation_int", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "71e1c9cf4d468f4c66f76d7a4215275d590d638c56a84ce00a9da324d7d79818", "warmup_time": -1}, "bench_random.RNG.time_32bit": {"code": "class RNG:\n    def time_32bit(self, bitgen):\n        min, max = self.uint32info.min, self.uint32info.max\n        if bitgen == 'numpy':\n            self.rg.randint(min, max + 1, nom_size, dtype=np.uint32)\n        else:\n            self.rg.integers(min, max + 1, nom_size, dtype=np.uint32)\n\n    def setup(self, bitgen):\n        if bitgen == 'numpy':\n            self.rg = np.random.RandomState()\n        else:\n            self.rg = Generator(getattr(np.random, bitgen)())\n        self.rg.random()\n        self.int32info = np.iinfo(np.int32)\n        self.uint32info = np.iinfo(np.uint32)\n        self.uint64info = np.iinfo(np.uint64)", "min_run_count": 2, "name": "bench_random.RNG.time_32bit", "number": 0, "param_names": ["rng"], "params": [["'PCG64'", "'MT19937'", "'Philox'", "'SFC64'", "'numpy'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "cb6866d2a229860446d329ed86cec74da9f3f495d544006e29dba8f0eb9a2a29", "warmup_time": -1}, "bench_random.RNG.time_64bit": {"code": "class RNG:\n    def time_64bit(self, bitgen):\n        min, max = self.uint64info.min, self.uint64info.max\n        if bitgen == 'numpy':\n            self.rg.randint(min, max + 1, nom_size, dtype=np.uint64)\n        else:\n            self.rg.integers(min, max + 1, nom_size, dtype=np.uint64)\n\n    def setup(self, bitgen):\n        if bitgen == 'numpy':\n            self.rg = np.random.RandomState()\n        else:\n            self.rg = Generator(getattr(np.random, bitgen)())\n        self.rg.random()\n        self.int32info = np.iinfo(np.int32)\n        self.uint32info = np.iinfo(np.uint32)\n        self.uint64info = np.iinfo(np.uint64)", "min_run_count": 2, "name": "bench_random.RNG.time_64bit", "number": 0, "param_names": ["rng"], "params": [["'PCG64'", "'MT19937'", "'Philox'", "'SFC64'", "'numpy'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f427158e9352900d3a4249235778210c55419c9a6abd475fba10b12a612f62cc", "warmup_time": -1}, "bench_random.RNG.time_normal_zig": {"code": "class RNG:\n    def time_normal_zig(self, bitgen):\n        self.rg.standard_normal(nom_size)\n\n    def setup(self, bitgen):\n        if bitgen == 'numpy':\n            self.rg = np.random.RandomState()\n        else:\n            self.rg = Generator(getattr(np.random, bitgen)())\n        self.rg.random()\n        self.int32info = np.iinfo(np.int32)\n        self.uint32info = np.iinfo(np.uint32)\n        self.uint64info = np.iinfo(np.uint64)", "min_run_count": 2, "name": "bench_random.RNG.time_normal_zig", "number": 0, "param_names": ["rng"], "params": [["'PCG64'", "'MT19937'", "'Philox'", "'SFC64'", "'numpy'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b07ff35f63c9be7b9129a247a6f3b90d3209858b607b91e42b0be9c75a7cdf2f", "warmup_time": -1}, "bench_random.RNG.time_raw": {"code": "class RNG:\n    def time_raw(self, bitgen):\n        if bitgen == 'numpy':\n            self.rg.random_integers(self.int32info.max, size=nom_size)\n        else:\n            self.rg.integers(self.int32info.max, size=nom_size, endpoint=True)\n\n    def setup(self, bitgen):\n        if bitgen == 'numpy':\n            self.rg = np.random.RandomState()\n        else:\n            self.rg = Generator(getattr(np.random, bitgen)())\n        self.rg.random()\n        self.int32info = np.iinfo(np.int32)\n        self.uint32info = np.iinfo(np.uint32)\n        self.uint64info = np.iinfo(np.uint64)", "min_run_count": 2, "name": "bench_random.RNG.time_raw", "number": 0, "param_names": ["rng"], "params": [["'PCG64'", "'MT19937'", "'Philox'", "'SFC64'", "'numpy'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9a10bd242f667f726dd0b180cc185c6eb1a96cc178b96a6f905d269b2f8641c6", "warmup_time": -1}, "bench_random.Randint.time_randint_fast": {"code": "class Randint:\n    def time_randint_fast(self):\n        \"\"\"Compare to uint32 below\"\"\"\n        np.random.randint(0, 2**30, size=10**5)", "min_run_count": 2, "name": "bench_random.Randint.time_randint_fast", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "bb8c6b342d125e6ce85eba74f81e9a3f69eb3a1f4948921a73b680d3ea4f312e", "warmup_time": -1}, "bench_random.Randint.time_randint_slow": {"code": "class Randint:\n    def time_randint_slow(self):\n        \"\"\"Compare to uint32 below\"\"\"\n        np.random.randint(0, 2**30 + 1, size=10**5)", "min_run_count": 2, "name": "bench_random.Randint.time_randint_slow", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "97dcc24881c776455f5c6a04bec764909ac9a0e4f7cfde6413f8d60a487adbc5", "warmup_time": -1}, "bench_random.Randint_dtype.time_randint_fast": {"code": "class Randint_dtype:\n    def time_randint_fast(self, name):\n        high = self.high[name]\n        np.random.randint(0, high, size=10**5, dtype=name)\n\n    def setup(self, name):\n        from numpy.lib import NumpyVersion\n        if NumpyVersion(np.__version__) < '1.11.0.dev0':\n            raise NotImplementedError", "min_run_count": 2, "name": "bench_random.Randint_dtype.time_randint_fast", "number": 0, "param_names": ["dtype"], "params": [["'bool'", "'uint8'", "'uint16'", "'uint32'", "'uint64'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "686cd267595db36e1a5b21a65b9f0a77efb9cd65c4b1b7f631b7ffe955087d2b", "warmup_time": -1}, "bench_random.Randint_dtype.time_randint_slow": {"code": "class Randint_dtype:\n    def time_randint_slow(self, name):\n        high = self.high[name]\n        np.random.randint(0, high + 1, size=10**5, dtype=name)\n\n    def setup(self, name):\n        from numpy.lib import NumpyVersion\n        if NumpyVersion(np.__version__) < '1.11.0.dev0':\n            raise NotImplementedError", "min_run_count": 2, "name": "bench_random.Randint_dtype.time_randint_slow", "number": 0, "param_names": ["dtype"], "params": [["'bool'", "'uint8'", "'uint16'", "'uint32'", "'uint64'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "5288dc43a24dc0ad0085d813bc9c7f1501cff277adbffe869256718c92d76bbd", "warmup_time": -1}, "bench_random.Random.time_rng": {"code": "class Random:\n    def time_rng(self, name):\n        self.func(*self.params)\n\n    def setup(self, name):\n        items = name.split()\n        name = items.pop(0)\n        params = [float(x) for x in items]\n    \n        self.func = getattr(np.random, name)\n        self.params = tuple(params) + ((100, 100),)", "min_run_count": 2, "name": "bench_random.Random.time_rng", "number": 0, "param_names": ["param1"], "params": [["'normal'", "'uniform'", "'weibull 1'", "'binomial 10 0.5'", "'poisson 10'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "20d7c6d641e664676dba02e39f4358735344639b5c0798301d8702c6d4b0cb1f", "warmup_time": -1}, "bench_random.Shuffle.time_100000": {"code": "class Shuffle:\n    def time_100000(self):\n        np.random.shuffle(self.a)\n\n    def setup(self):\n        self.a = np.arange(100000)", "min_run_count": 2, "name": "bench_random.Shuffle.time_100000", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "008b63ed906c93eff862ba9a6aad85a0ed290deb009fa1085447a66b23e8d717", "warmup_time": -1}, "bench_records.Records.time_fromarrays_formats_as_list": {"code": "class Records:\n    def time_fromarrays_formats_as_list(self):\n        np.core.records.fromarrays(self.arrays, formats=self.formats)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number", "min_run_count": 2, "name": "bench_records.Records.time_fromarrays_formats_as_list", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "621e3b86832fdf9664c674069c3d1fbeb10cddf260e4c4b4a3b47ec05c71fbb1", "warmup_time": -1}, "bench_records.Records.time_fromarrays_formats_as_string": {"code": "class Records:\n    def time_fromarrays_formats_as_string(self):\n        np.core.records.fromarrays(self.arrays, formats=self.formats_str)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number", "min_run_count": 2, "name": "bench_records.Records.time_fromarrays_formats_as_string", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "856269c6f0b81d23f7e9fd24a17d47ff29142465b7d193cc5de403c1c6fdd235", "warmup_time": -1}, "bench_records.Records.time_fromarrays_w_dtype": {"code": "class Records:\n    def time_fromarrays_w_dtype(self):\n        np.core.records.fromarrays(self.arrays, dtype=self.dtype_)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number", "min_run_count": 2, "name": "bench_records.Records.time_fromarrays_w_dtype", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7535af7828629025f0ce5b805ff36e75f86ca00ab8925e3205495d9c0cb452d5", "warmup_time": -1}, "bench_records.Records.time_fromarrays_wo_dtype": {"code": "class Records:\n    def time_fromarrays_wo_dtype(self):\n        np.core.records.fromarrays(self.arrays)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number", "min_run_count": 2, "name": "bench_records.Records.time_fromarrays_wo_dtype", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b1e0d759f5513721633b892f2f293f27755a92bd041c2b7b5aee9baaa692f0dc", "warmup_time": -1}, "bench_records.Records.time_fromstring_formats_as_list": {"code": "class Records:\n    def time_fromstring_formats_as_list(self):\n        np.core.records.fromstring(self.buffer, formats=self.formats)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number", "min_run_count": 2, "name": "bench_records.Records.time_fromstring_formats_as_list", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "44623a8f23a4a6d5f9e6fd58862f0f43ffa66d92b1dc983b93c1c5d4ca04b939", "warmup_time": -1}, "bench_records.Records.time_fromstring_formats_as_string": {"code": "class Records:\n    def time_fromstring_formats_as_string(self):\n        np.core.records.fromstring(self.buffer, formats=self.formats_str)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number", "min_run_count": 2, "name": "bench_records.Records.time_fromstring_formats_as_string", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e9e4abd8a0616b036d2d91c9f40cf36ae088fee51103890a20583acf8edc9496", "warmup_time": -1}, "bench_records.Records.time_fromstring_w_dtype": {"code": "class Records:\n    def time_fromstring_w_dtype(self):\n        np.core.records.fromstring(self.buffer, dtype=self.dtype_)\n\n    def setup(self):\n        self.l50 = np.arange(1000)\n        self.fields_number = 10000\n        self.arrays = [self.l50 for _ in range(self.fields_number)]\n        self.formats = [self.l50.dtype.str for _ in range(self.fields_number)]\n        self.formats_str = ','.join(self.formats)\n        self.dtype_ = np.dtype(\n            [\n                ('field_{}'.format(i), self.l50.dtype.str)\n                for i in range(self.fields_number)\n            ]\n        )\n        self.buffer = self.l50.tostring() * self.fields_number", "min_run_count": 2, "name": "bench_records.Records.time_fromstring_w_dtype", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "788e2036232e1c48d6ed7b1c95326e4007fa638fa1d38a9935a20bb4ffc0b501", "warmup_time": -1}, "bench_reduce.AddReduce.time_axis_0": {"code": "class AddReduce:\n    def time_axis_0(self):\n        [np.add.reduce(a, axis=0) for a in self.squares]\n\n    def setup(self):\n        self.squares = get_squares().values()", "min_run_count": 2, "name": "bench_reduce.AddReduce.time_axis_0", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2af9934f0fbbc8408edad22dfb037bd0861b919664055e5fe609f4058bffd1d9", "warmup_time": -1}, "bench_reduce.AddReduce.time_axis_1": {"code": "class AddReduce:\n    def time_axis_1(self):\n        [np.add.reduce(a, axis=1) for a in self.squares]\n\n    def setup(self):\n        self.squares = get_squares().values()", "min_run_count": 2, "name": "bench_reduce.AddReduce.time_axis_1", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9e926386f8f433cfbcbea78e95c4f2cb3755951748b965430ab5e407be5d4b66", "warmup_time": -1}, "bench_reduce.AddReduceSeparate.time_reduce": {"code": "class AddReduceSeparate:\n    def time_reduce(self, axis, typename):\n        np.add.reduce(self.a, axis=axis)\n\n    def setup(self, axis, typename):\n        self.a = get_squares()[typename]", "min_run_count": 2, "name": "bench_reduce.AddReduceSeparate.time_reduce", "number": 0, "param_names": ["axis", "type"], "params": [["0", "1"], ["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9fe950161a3a7c6883be4205a98ad6f3b268adcb3448bb900588c9a05f1b4d41", "warmup_time": -1}, "bench_reduce.AnyAll.time_all_fast": {"code": "class AnyAll:\n    def time_all_fast(self):\n        self.zeros.all()\n\n    def setup(self):\n        # avoid np.zeros's lazy allocation that would\n        # cause page faults during benchmark\n        self.zeros = np.full(100000, 0, bool)\n        self.ones = np.full(100000, 1, bool)", "min_run_count": 2, "name": "bench_reduce.AnyAll.time_all_fast", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "337055e8376d23b58323da5853a1ce18e7025e49c95efd41d01732d37a916411", "warmup_time": -1}, "bench_reduce.AnyAll.time_all_slow": {"code": "class AnyAll:\n    def time_all_slow(self):\n        self.ones.all()\n\n    def setup(self):\n        # avoid np.zeros's lazy allocation that would\n        # cause page faults during benchmark\n        self.zeros = np.full(100000, 0, bool)\n        self.ones = np.full(100000, 1, bool)", "min_run_count": 2, "name": "bench_reduce.AnyAll.time_all_slow", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9e00fb89e58c9b2b417aa7e9a7920769076051c19ff0c466ae4aab094bdb5dc3", "warmup_time": -1}, "bench_reduce.AnyAll.time_any_fast": {"code": "class AnyAll:\n    def time_any_fast(self):\n        self.ones.any()\n\n    def setup(self):\n        # avoid np.zeros's lazy allocation that would\n        # cause page faults during benchmark\n        self.zeros = np.full(100000, 0, bool)\n        self.ones = np.full(100000, 1, bool)", "min_run_count": 2, "name": "bench_reduce.AnyAll.time_any_fast", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1bed9465b7afde4e6e437837f60b2b4315f05e9186392b2df64a3ecfd4fb8b98", "warmup_time": -1}, "bench_reduce.AnyAll.time_any_slow": {"code": "class AnyAll:\n    def time_any_slow(self):\n        self.zeros.any()\n\n    def setup(self):\n        # avoid np.zeros's lazy allocation that would\n        # cause page faults during benchmark\n        self.zeros = np.full(100000, 0, bool)\n        self.ones = np.full(100000, 1, bool)", "min_run_count": 2, "name": "bench_reduce.AnyAll.time_any_slow", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "fdb7e7815fcaa4c4c0a8613bdd1f28b855d03f3732f123a144a613fcaa23d01f", "warmup_time": -1}, "bench_reduce.ArgMax.time_argmax": {"code": "class ArgMax:\n    def time_argmax(self, dtype):\n        np.argmax(self.d)\n\n    def setup(self, dtype):\n        self.d = np.zeros(200000, dtype=dtype)", "min_run_count": 2, "name": "bench_reduce.ArgMax.time_argmax", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.int8'>", "<class 'numpy.uint8'>", "<class 'numpy.int16'>", "<class 'numpy.uint16'>", "<class 'numpy.int32'>", "<class 'numpy.uint32'>", "<class 'numpy.int64'>", "<class 'numpy.uint64'>", "<class 'numpy.float32'>", "<class 'numpy.float64'>", "<class 'bool'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2843a21fe3f8f99974c2c8e3ea2c53595d3246781016dfc14abd6116d720ba5e", "warmup_time": -1}, "bench_reduce.ArgMin.time_argmin": {"code": "class ArgMin:\n    def time_argmin(self, dtype):\n        np.argmin(self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(200000, dtype=dtype)", "min_run_count": 2, "name": "bench_reduce.ArgMin.time_argmin", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.int8'>", "<class 'numpy.uint8'>", "<class 'numpy.int16'>", "<class 'numpy.uint16'>", "<class 'numpy.int32'>", "<class 'numpy.uint32'>", "<class 'numpy.int64'>", "<class 'numpy.uint64'>", "<class 'numpy.float32'>", "<class 'numpy.float64'>", "<class 'bool'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "d27ef6416f131ec01126aa5533d3eb7c800f5685ce71066fc26f93b281289d1d", "warmup_time": -1}, "bench_reduce.FMinMax.time_max": {"code": "class FMinMax:\n    def time_max(self, dtype):\n        np.fmax.reduce(self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)", "min_run_count": 2, "name": "bench_reduce.FMinMax.time_max", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3fedfd780a61cfbd72db31664ca87b48f7046888915accac1229b660d9226fb0", "warmup_time": -1}, "bench_reduce.FMinMax.time_min": {"code": "class FMinMax:\n    def time_min(self, dtype):\n        np.fmin.reduce(self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)", "min_run_count": 2, "name": "bench_reduce.FMinMax.time_min", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "28ddb46378c2fad1fdfb475f928b1e3763f86a66ae792daabe87f2828c53db81", "warmup_time": -1}, "bench_reduce.MinMax.time_max": {"code": "class MinMax:\n    def time_max(self, dtype):\n        np.max(self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)", "min_run_count": 2, "name": "bench_reduce.MinMax.time_max", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.int8'>", "<class 'numpy.uint8'>", "<class 'numpy.int16'>", "<class 'numpy.uint16'>", "<class 'numpy.int32'>", "<class 'numpy.uint32'>", "<class 'numpy.int64'> (0)", "<class 'numpy.uint64'>", "<class 'numpy.float32'>", "<class 'numpy.float64'>", "<class 'numpy.int64'> (1)"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "514f3cab642bc43d526e91045a6374f6aca5840683583600a5d8cbe85fb787dc", "warmup_time": -1}, "bench_reduce.MinMax.time_min": {"code": "class MinMax:\n    def time_min(self, dtype):\n        np.min(self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)", "min_run_count": 2, "name": "bench_reduce.MinMax.time_min", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.int8'>", "<class 'numpy.uint8'>", "<class 'numpy.int16'>", "<class 'numpy.uint16'>", "<class 'numpy.int32'>", "<class 'numpy.uint32'>", "<class 'numpy.int64'> (0)", "<class 'numpy.uint64'>", "<class 'numpy.float32'>", "<class 'numpy.float64'>", "<class 'numpy.int64'> (1)"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e6b22576b375226197a12de92f4a1cc57b3559e74d1fffbf7c304ae08ead1283", "warmup_time": -1}, "bench_reduce.SmallReduction.time_small": {"code": "class SmallReduction:\n    def time_small(self):\n        np.sum(self.d)\n\n    def setup(self):\n        self.d = np.ones(100, dtype=np.float32)", "min_run_count": 2, "name": "bench_reduce.SmallReduction.time_small", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6c036bc421f0fb669164ceb2814d8765d6f3a6c7c38f5e2e55a3fc00945c9468", "warmup_time": -1}, "bench_scalar.ScalarMath.time_abs": {"code": "class ScalarMath:\n    def time_abs(self, typename):\n        n = self.num\n        res = abs(abs(abs(abs(abs(abs(abs(abs(abs(abs(n))))))))))\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)", "min_run_count": 2, "name": "bench_scalar.ScalarMath.time_abs", "number": 0, "param_names": ["type"], "params": [["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7591b0e037d086027d27593dc93810522765dd7ad6ba7bf0e4abd3a4bfbd9c09", "warmup_time": -1}, "bench_scalar.ScalarMath.time_add_int32_other": {"code": "class ScalarMath:\n    def time_add_int32_other(self, typename):\n        # Some mixed cases are fast, some are slow, this documents these\n        # differences.  (When writing, it was fast if the type of the result\n        # is one of the inputs.)\n        int32 = self.int32\n        other = self.num\n        int32 + other\n        int32 + other\n        int32 + other\n        int32 + other\n        int32 + other\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)", "min_run_count": 2, "name": "bench_scalar.ScalarMath.time_add_int32_other", "number": 0, "param_names": ["type"], "params": [["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "cf0cc872be896171e60522d76cad520207b9dda6c66c74b1ea587f865e8b3c3b", "warmup_time": -1}, "bench_scalar.ScalarMath.time_add_int32arr_and_other": {"code": "class ScalarMath:\n    def time_add_int32arr_and_other(self, typename):\n        # `arr + scalar` hits the normal ufunc (array) paths.\n        int32 = self.int32arr\n        other = self.num\n        int32 + other\n        int32 + other\n        int32 + other\n        int32 + other\n        int32 + other\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)", "min_run_count": 2, "name": "bench_scalar.ScalarMath.time_add_int32arr_and_other", "number": 0, "param_names": ["type"], "params": [["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a3989983f83f427ef4dfdf79504251c6d93fda93c4fda51b196ddc57a66f37fc", "warmup_time": -1}, "bench_scalar.ScalarMath.time_add_other_and_int32arr": {"code": "class ScalarMath:\n    def time_add_other_and_int32arr(self, typename):\n        # `scalar + arr` at some point hit scalar paths in some cases, and\n        # these paths could be optimized more easily\n        int32 = self.int32arr\n        other = self.num\n        other + int32\n        other + int32\n        other + int32\n        other + int32\n        other + int32\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)", "min_run_count": 2, "name": "bench_scalar.ScalarMath.time_add_other_and_int32arr", "number": 0, "param_names": ["type"], "params": [["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "baba6c5e7b280c73a4c9679807b7aeff690ddf89e5f02bd480dde007c5675bf6", "warmup_time": -1}, "bench_scalar.ScalarMath.time_addition": {"code": "class ScalarMath:\n    def time_addition(self, typename):\n        n = self.num\n        res = n + n + n + n + n + n + n + n + n + n\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)", "min_run_count": 2, "name": "bench_scalar.ScalarMath.time_addition", "number": 0, "param_names": ["type"], "params": [["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c6acd8c382e717a438cd22d4839a2e81832b6976d1cb5bf72c60fe11d51e096e", "warmup_time": -1}, "bench_scalar.ScalarMath.time_addition_pyint": {"code": "class ScalarMath:\n    def time_addition_pyint(self, typename):\n        n = self.num\n        res = n + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)", "min_run_count": 2, "name": "bench_scalar.ScalarMath.time_addition_pyint", "number": 0, "param_names": ["type"], "params": [["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f0cd5a595ffe5e3294dda632d0c88da1a5683fefef50109bd123ceef32ec2b50", "warmup_time": -1}, "bench_scalar.ScalarMath.time_multiplication": {"code": "class ScalarMath:\n    def time_multiplication(self, typename):\n        n = self.num\n        res = n * n * n * n * n * n * n * n * n * n\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)", "min_run_count": 2, "name": "bench_scalar.ScalarMath.time_multiplication", "number": 0, "param_names": ["type"], "params": [["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ba5b9f9117a1a7b3b77dff2afef34fac8968c6447e7c743ae8ed26f80935e95a", "warmup_time": -1}, "bench_scalar.ScalarMath.time_power_of_two": {"code": "class ScalarMath:\n    def time_power_of_two(self, typename):\n        n = self.num\n        res = n**2, n**2, n**2, n**2, n**2, n**2, n**2, n**2, n**2, n**2\n\n    def setup(self, typename):\n        self.num = np.dtype(typename).type(2)\n        self.int32 = np.int32(2)\n        self.int32arr = np.array(2, dtype=np.int32)", "min_run_count": 2, "name": "bench_scalar.ScalarMath.time_power_of_two", "number": 0, "param_names": ["type"], "params": [["'int16'", "'float16'", "'int32'", "'float32'", "'int64'", "'float64'", "'complex64'", "'longfloat'", "'complex128'", "'complex256'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "383b216c2291472c6063c61807295eda2a0b5e7b2378effbfe287b1b347249f6", "warmup_time": -1}, "bench_shape_base.Block.time_3d": {"code": "class Block3D:\n    def time_3d(self, n, mode):\n        if mode == 'block':\n            np.block(self.block)\n        else:  # mode == 'copy'\n            [arr.copy() for arr in self.arr_list]\n\n    def setup(self, n, mode):\n        # Slow setup method: hence separated from the others above\n        self.a000 = np.ones((2 * n, 2 * n, 2 * n), int) * 1\n    \n        self.a100 = np.ones((3 * n, 2 * n, 2 * n), int) * 2\n        self.a010 = np.ones((2 * n, 3 * n, 2 * n), int) * 3\n        self.a001 = np.ones((2 * n, 2 * n, 3 * n), int) * 4\n    \n        self.a011 = np.ones((2 * n, 3 * n, 3 * n), int) * 5\n        self.a101 = np.ones((3 * n, 2 * n, 3 * n), int) * 6\n        self.a110 = np.ones((3 * n, 3 * n, 2 * n), int) * 7\n    \n        self.a111 = np.ones((3 * n, 3 * n, 3 * n), int) * 8\n    \n        self.block = [\n            [\n                [self.a000, self.a001],\n                [self.a010, self.a011],\n            ],\n            [\n                [self.a100, self.a101],\n                [self.a110, self.a111],\n            ]\n        ]\n        self.arr_list = [a\n                         for two_d in self.block\n                         for one_d in two_d\n                         for a in one_d]", "min_run_count": 2, "name": "bench_shape_base.Block.time_3d", "number": 0, "param_names": ["n", "mode"], "params": [["1", "10", "100"], ["'block'", "'copy'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b9a48960b73fb3f85bfc2dc0e571c65492e2e23f6ba46efdbaa83c229a840ed3", "warmup_time": -1}, "bench_shape_base.Block.time_block_complicated": {"code": "class Block:\n    def time_block_complicated(self, n):\n        np.block([[self.one_2d, self.two_2d],\n                  [self.three_2d],\n                  [self.four_1d],\n                  [self.five_0d, self.six_1d],\n                  [self.zero_2d]])\n\n    def setup(self, n):\n        self.a_2d = np.ones((2 * n, 2 * n))\n        self.b_1d = np.ones(2 * n)\n        self.b_2d = 2 * self.a_2d\n    \n        self.a = np.ones(3 * n)\n        self.b = np.ones(3 * n)\n    \n        self.one_2d = np.ones((1 * n, 3 * n))\n        self.two_2d = np.ones((1 * n, 3 * n))\n        self.three_2d = np.ones((1 * n, 6 * n))\n        self.four_1d = np.ones(6 * n)\n        self.five_0d = np.ones(1 * n)\n        self.six_1d = np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero_2d = np.full((2 * n, 6 * n), 0)\n    \n        self.one = np.ones(3 * n)\n        self.two = 2 * np.ones((3, 3 * n))\n        self.three = 3 * np.ones(3 * n)\n        self.four = 4 * np.ones(3 * n)\n        self.five = 5 * np.ones(1 * n)\n        self.six = 6 * np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero = np.full((2 * n, 6 * n), 0)", "min_run_count": 2, "name": "bench_shape_base.Block.time_block_complicated", "number": 0, "param_names": ["size"], "params": [["1", "10", "100"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f5020e81ec4b44cc8c43385d45447eb00773324ed075f3e140a83e6deea1b5b1", "warmup_time": -1}, "bench_shape_base.Block.time_block_simple_column_wise": {"code": "class Block:\n    def time_block_simple_column_wise(self, n):\n        np.block([[self.a_2d], [self.b_2d]])\n\n    def setup(self, n):\n        self.a_2d = np.ones((2 * n, 2 * n))\n        self.b_1d = np.ones(2 * n)\n        self.b_2d = 2 * self.a_2d\n    \n        self.a = np.ones(3 * n)\n        self.b = np.ones(3 * n)\n    \n        self.one_2d = np.ones((1 * n, 3 * n))\n        self.two_2d = np.ones((1 * n, 3 * n))\n        self.three_2d = np.ones((1 * n, 6 * n))\n        self.four_1d = np.ones(6 * n)\n        self.five_0d = np.ones(1 * n)\n        self.six_1d = np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero_2d = np.full((2 * n, 6 * n), 0)\n    \n        self.one = np.ones(3 * n)\n        self.two = 2 * np.ones((3, 3 * n))\n        self.three = 3 * np.ones(3 * n)\n        self.four = 4 * np.ones(3 * n)\n        self.five = 5 * np.ones(1 * n)\n        self.six = 6 * np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero = np.full((2 * n, 6 * n), 0)", "min_run_count": 2, "name": "bench_shape_base.Block.time_block_simple_column_wise", "number": 0, "param_names": ["size"], "params": [["1", "10", "100"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ace4adce497cb59167431a3cb0e9336e9a4ca74c5a028728f072cb377034afac", "warmup_time": -1}, "bench_shape_base.Block.time_block_simple_row_wise": {"code": "class Block:\n    def time_block_simple_row_wise(self, n):\n        np.block([self.a_2d, self.b_2d])\n\n    def setup(self, n):\n        self.a_2d = np.ones((2 * n, 2 * n))\n        self.b_1d = np.ones(2 * n)\n        self.b_2d = 2 * self.a_2d\n    \n        self.a = np.ones(3 * n)\n        self.b = np.ones(3 * n)\n    \n        self.one_2d = np.ones((1 * n, 3 * n))\n        self.two_2d = np.ones((1 * n, 3 * n))\n        self.three_2d = np.ones((1 * n, 6 * n))\n        self.four_1d = np.ones(6 * n)\n        self.five_0d = np.ones(1 * n)\n        self.six_1d = np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero_2d = np.full((2 * n, 6 * n), 0)\n    \n        self.one = np.ones(3 * n)\n        self.two = 2 * np.ones((3, 3 * n))\n        self.three = 3 * np.ones(3 * n)\n        self.four = 4 * np.ones(3 * n)\n        self.five = 5 * np.ones(1 * n)\n        self.six = 6 * np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero = np.full((2 * n, 6 * n), 0)", "min_run_count": 2, "name": "bench_shape_base.Block.time_block_simple_row_wise", "number": 0, "param_names": ["size"], "params": [["1", "10", "100"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7e68cd3ac85d87ea0960b4e3480f3447d612752cc5da0d8e622d44883521fb9a", "warmup_time": -1}, "bench_shape_base.Block.time_nested": {"code": "class Block:\n    def time_nested(self, n):\n        np.block([\n            [\n                np.block([\n                   [self.one],\n                   [self.three],\n                   [self.four]\n                ]),\n                self.two\n            ],\n            [self.five, self.six],\n            [self.zero]\n        ])\n\n    def setup(self, n):\n        self.a_2d = np.ones((2 * n, 2 * n))\n        self.b_1d = np.ones(2 * n)\n        self.b_2d = 2 * self.a_2d\n    \n        self.a = np.ones(3 * n)\n        self.b = np.ones(3 * n)\n    \n        self.one_2d = np.ones((1 * n, 3 * n))\n        self.two_2d = np.ones((1 * n, 3 * n))\n        self.three_2d = np.ones((1 * n, 6 * n))\n        self.four_1d = np.ones(6 * n)\n        self.five_0d = np.ones(1 * n)\n        self.six_1d = np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero_2d = np.full((2 * n, 6 * n), 0)\n    \n        self.one = np.ones(3 * n)\n        self.two = 2 * np.ones((3, 3 * n))\n        self.three = 3 * np.ones(3 * n)\n        self.four = 4 * np.ones(3 * n)\n        self.five = 5 * np.ones(1 * n)\n        self.six = 6 * np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero = np.full((2 * n, 6 * n), 0)", "min_run_count": 2, "name": "bench_shape_base.Block.time_nested", "number": 0, "param_names": ["size"], "params": [["1", "10", "100"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "76a91fd4afc8a0e86b6afd79d5f3ea4ecd9fbbef884ae0500b470509e9e8b67e", "warmup_time": -1}, "bench_shape_base.Block.time_no_lists": {"code": "class Block:\n    def time_no_lists(self, n):\n        np.block(1)\n        np.block(np.eye(3 * n))\n\n    def setup(self, n):\n        self.a_2d = np.ones((2 * n, 2 * n))\n        self.b_1d = np.ones(2 * n)\n        self.b_2d = 2 * self.a_2d\n    \n        self.a = np.ones(3 * n)\n        self.b = np.ones(3 * n)\n    \n        self.one_2d = np.ones((1 * n, 3 * n))\n        self.two_2d = np.ones((1 * n, 3 * n))\n        self.three_2d = np.ones((1 * n, 6 * n))\n        self.four_1d = np.ones(6 * n)\n        self.five_0d = np.ones(1 * n)\n        self.six_1d = np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero_2d = np.full((2 * n, 6 * n), 0)\n    \n        self.one = np.ones(3 * n)\n        self.two = 2 * np.ones((3, 3 * n))\n        self.three = 3 * np.ones(3 * n)\n        self.four = 4 * np.ones(3 * n)\n        self.five = 5 * np.ones(1 * n)\n        self.six = 6 * np.ones(5 * n)\n        # avoid np.zeros's lazy allocation that might cause\n        # page faults during benchmark\n        self.zero = np.full((2 * n, 6 * n), 0)", "min_run_count": 2, "name": "bench_shape_base.Block.time_no_lists", "number": 0, "param_names": ["size"], "params": [["1", "10", "100"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6bc26f65802cda859473d4bbdd7c111e5084ace7bd39cca0c9ca3aad06eee9ea", "warmup_time": -1}, "bench_shape_base.Block2D.time_block2d": {"code": "class Block2D:\n    def time_block2d(self, shape, dtype, n_chunks):\n        np.block(self.block_list)\n\n    def setup(self, shape, dtype, n_chunks):\n    \n        self.block_list = [\n             [np.full(shape=[s//n_chunk for s, n_chunk in zip(shape, n_chunks)],\n                     fill_value=1, dtype=dtype) for _ in range(n_chunks[1])]\n            for _ in range(n_chunks[0])\n        ]", "min_run_count": 2, "name": "bench_shape_base.Block2D.time_block2d", "number": 0, "param_names": ["shape", "dtype", "n_chunks"], "params": [["(16, 16)", "(32, 32)", "(64, 64)", "(128, 128)", "(256, 256)", "(512, 512)", "(1024, 1024)"], ["'uint8'", "'uint16'", "'uint32'", "'uint64'"], ["(2, 2)", "(4, 4)"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "93de8827eb35255e1f0daea4c5054d670f73b0c62c2cb54fc42a81e29c851ea8", "warmup_time": -1}, "bench_shape_base.Kron.time_arr_kron": {"code": "class Kron:\n    def time_arr_kron(self):\n        np.kron(self.large_arr, self.large_arr)\n\n    def setup(self):\n        self.large_arr = np.random.random((10,) * 4)\n        self.large_mat = np.mat(np.random.random((100, 100)))\n        self.scalar = 7", "min_run_count": 2, "name": "bench_shape_base.Kron.time_arr_kron", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "a80a13af728a2bddb31d5f614f55b42a0f69e942cecdc166eef6c477a96d410a", "warmup_time": -1}, "bench_shape_base.Kron.time_mat_kron": {"code": "class Kron:\n    def time_mat_kron(self):\n        np.kron(self.large_mat, self.large_mat)\n\n    def setup(self):\n        self.large_arr = np.random.random((10,) * 4)\n        self.large_mat = np.mat(np.random.random((100, 100)))\n        self.scalar = 7", "min_run_count": 2, "name": "bench_shape_base.Kron.time_mat_kron", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "943afd31dd1979798974bf63c1caf254cdcf14d0abbf1759d6bfee249a6d8d1c", "warmup_time": -1}, "bench_shape_base.Kron.time_scalar_kron": {"code": "class Kron:\n    def time_scalar_kron(self):\n        np.kron(self.large_arr, self.scalar)\n\n    def setup(self):\n        self.large_arr = np.random.random((10,) * 4)\n        self.large_mat = np.mat(np.random.random((100, 100)))\n        self.scalar = 7", "min_run_count": 2, "name": "bench_shape_base.Kron.time_scalar_kron", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "61bfc4a70432b5504313a46d3b7996d5531b1c8502a980b8bb2bdd3bab18398a", "warmup_time": -1}, "bench_strings.StringComparisons.time_compare_different": {"code": "class StringComparisons:\n    def time_compare_different(self, shape, dtype, contig, operator):\n        self.operator(self.arr, self.arr_different)\n\n    def setup(self, shape, dtype, contig, operator):\n        self.arr = np.arange(np.prod(shape)).astype(dtype).reshape(shape)\n        self.arr_identical = self.arr.copy()\n        self.arr_different = self.arr[::-1].copy()\n    \n        if not contig:\n            self.arr = self.arr[..., ::2]\n            self.arr_identical = self.arr_identical[..., ::2]\n            self.arr_different = self.arr_different[..., ::2]\n    \n        self.operator = _OPERATORS[operator]", "min_run_count": 2, "name": "bench_strings.StringComparisons.time_compare_different", "number": 0, "param_names": ["shape", "dtype", "contig", "operator"], "params": [["100", "10000", "(1000, 20)"], ["'U'", "'S'"], ["True", "False"], ["'=='", "'!='", "'<'", "'<='", "'>'", "'>='"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b18e3cc1b73c555958b266b870850fbd687b4b6f76ef8d91f4790b918360ddd3", "warmup_time": -1}, "bench_strings.StringComparisons.time_compare_identical": {"code": "class StringComparisons:\n    def time_compare_identical(self, shape, dtype, contig, operator):\n        self.operator(self.arr, self.arr_identical)\n\n    def setup(self, shape, dtype, contig, operator):\n        self.arr = np.arange(np.prod(shape)).astype(dtype).reshape(shape)\n        self.arr_identical = self.arr.copy()\n        self.arr_different = self.arr[::-1].copy()\n    \n        if not contig:\n            self.arr = self.arr[..., ::2]\n            self.arr_identical = self.arr_identical[..., ::2]\n            self.arr_different = self.arr_different[..., ::2]\n    \n        self.operator = _OPERATORS[operator]", "min_run_count": 2, "name": "bench_strings.StringComparisons.time_compare_identical", "number": 0, "param_names": ["shape", "dtype", "contig", "operator"], "params": [["100", "10000", "(1000, 20)"], ["'U'", "'S'"], ["True", "False"], ["'=='", "'!='", "'<'", "'<='", "'>'", "'>='"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "0833c4a040b6064547dc2deefb71b873a918b57116d4bf24d8594d62213834c0", "warmup_time": -1}, "bench_trim_zeros.TrimZeros.time_trim_zeros": {"code": "class TrimZeros:\n    def time_trim_zeros(self, dtype, size):\n        np.trim_zeros(self.array)\n\n    def setup(self, dtype, size):\n        n = size // 3\n        self.array = np.hstack([\n            np.zeros(n),\n            np.random.uniform(size=n),\n            np.zeros(n),\n        ]).astype(dtype)", "min_run_count": 2, "name": "bench_trim_zeros.TrimZeros.time_trim_zeros", "number": 0, "param_names": ["dtype", "size"], "params": [["dtype('int64')", "dtype('float64')", "dtype('complex128')", "dtype('bool')"], ["3000", "30000", "300000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "aa967874dea8e59b67e272fc23171647622694eafb5361945f785d17500097c3", "warmup_time": -1}, "bench_ufunc.ArgParsing.time_add_arg_parsing": {"code": "class ArgParsing:\n    def time_add_arg_parsing(self, arg_pack):\n        np.add(*arg_pack.args, **arg_pack.kwargs)", "min_run_count": 2, "name": "bench_ufunc.ArgParsing.time_add_arg_parsing", "number": 0, "param_names": ["arg_kwarg"], "params": [["(array(1.), array(2.))", "(array(1.), array(2.), array(3.))", "(array(1.), array(2.), out=array(3.))", "(array(1.), array(2.), out=(array(3.),))", "(array(1.), array(2.), out=array(3.), subok=True, where=True)", "(array(1.), array(2.), subok=True)", "(array(1.), array(2.), subok=True, where=True)", "(array(1.), array(2.), array(3.), subok=True, where=True)"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "7f8c98d0d3e4d48d2e4c78bc17a51a7d437b9b658ebf673e6829d145b6f109ce", "warmup_time": -1}, "bench_ufunc.ArgParsingReduce.time_add_reduce_arg_parsing": {"code": "class ArgParsingReduce:\n    def time_add_reduce_arg_parsing(self, arg_pack):\n        np.add.reduce(*arg_pack.args, **arg_pack.kwargs)", "min_run_count": 2, "name": "bench_ufunc.ArgParsingReduce.time_add_reduce_arg_parsing", "number": 0, "param_names": ["arg_kwarg"], "params": [["(array([0., 1.]))", "(array([0., 1.]), 0)", "(array([0., 1.]), axis=0)", "(array([0., 1.]), 0, None)", "(array([0., 1.]), axis=0, dtype=None)", "(array([0., 1.]), 0, None, array(0.))", "(array([0., 1.]), axis=0, dtype=None, out=array(0.))", "(array([0., 1.]), out=array(0.))"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ad65096c8033c570321d0bbb8effaa15bce7a6faab47e96c8848d61173fc5b40", "warmup_time": -1}, "bench_ufunc.BinaryBench.time_atan2_32": {"code": "class BinaryBench:\n    def time_atan2_32(self):\n        np.arctan2(self.a32, self.b32)\n\n    def setup(self):\n        N = 1000000\n        self.a32 = np.random.rand(N).astype(np.float32)\n        self.b32 = np.random.rand(N).astype(np.float32)\n        self.a64 = np.random.rand(N).astype(np.float64)\n        self.b64 = np.random.rand(N).astype(np.float64)", "min_run_count": 2, "name": "bench_ufunc.BinaryBench.time_atan2_32", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "67ef4b5108c72aac9cce82e393028199c310218cdeb012526ce1b5e138b42ef1", "warmup_time": -1}, "bench_ufunc.BinaryBench.time_atan2_64": {"code": "class BinaryBench:\n    def time_atan2_64(self):\n        np.arctan2(self.a64, self.b64)\n\n    def setup(self):\n        N = 1000000\n        self.a32 = np.random.rand(N).astype(np.float32)\n        self.b32 = np.random.rand(N).astype(np.float32)\n        self.a64 = np.random.rand(N).astype(np.float64)\n        self.b64 = np.random.rand(N).astype(np.float64)", "min_run_count": 2, "name": "bench_ufunc.BinaryBench.time_atan2_64", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "89fca4810c670156d37b37587cedcd769da5e382e9be1f1703e5c8f585d4c22a", "warmup_time": -1}, "bench_ufunc.BinaryBench.time_pow_32": {"code": "class BinaryBench:\n    def time_pow_32(self):\n        np.power(self.a32, self.b32)\n\n    def setup(self):\n        N = 1000000\n        self.a32 = np.random.rand(N).astype(np.float32)\n        self.b32 = np.random.rand(N).astype(np.float32)\n        self.a64 = np.random.rand(N).astype(np.float64)\n        self.b64 = np.random.rand(N).astype(np.float64)", "min_run_count": 2, "name": "bench_ufunc.BinaryBench.time_pow_32", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "2ed600ab4bb912d76a1f85a05fbda0e66fde5e590c41c46c0f2875610107626a", "warmup_time": -1}, "bench_ufunc.BinaryBench.time_pow_64": {"code": "class BinaryBench:\n    def time_pow_64(self):\n        np.power(self.a64, self.b64)\n\n    def setup(self):\n        N = 1000000\n        self.a32 = np.random.rand(N).astype(np.float32)\n        self.b32 = np.random.rand(N).astype(np.float32)\n        self.a64 = np.random.rand(N).astype(np.float64)\n        self.b64 = np.random.rand(N).astype(np.float64)", "min_run_count": 2, "name": "bench_ufunc.BinaryBench.time_pow_64", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3083d3915217eeea9f15481985024ceb09457a6793600c6bafc8ef736389a4f0", "warmup_time": -1}, "bench_ufunc.Broadcast.time_broadcast": {"code": "class Broadcast:\n    def time_broadcast(self):\n        self.d - self.e\n\n    def setup(self):\n        self.d = np.ones((50000, 100), dtype=np.float64)\n        self.e = np.ones((100,), dtype=np.float64)", "min_run_count": 2, "name": "bench_ufunc.Broadcast.time_broadcast", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "131ce9ba025e2d78a4dfdbaf95871da67ac00aac41956c1ad64741a2102ec6c5", "warmup_time": -1}, "bench_ufunc.Custom.time_and_bool": {"code": "class Custom:\n    def time_and_bool(self):\n        (self.b & self.b)\n\n    def setup(self):\n        self.b = np.ones(20000, dtype=bool)\n        self.b_small = np.ones(3, dtype=bool)", "min_run_count": 2, "name": "bench_ufunc.Custom.time_and_bool", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3dd025dd82113e4583d8a53325342c05e514b2a2a564dcb67b65ea5b7bddd7a2", "warmup_time": -1}, "bench_ufunc.Custom.time_and_bool_small": {"code": "class Custom:\n    def time_and_bool_small(self):\n        (self.b_small & self.b_small)\n\n    def setup(self):\n        self.b = np.ones(20000, dtype=bool)\n        self.b_small = np.ones(3, dtype=bool)", "min_run_count": 2, "name": "bench_ufunc.Custom.time_and_bool_small", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "842b3a0217604abba50614743087d593025ac6b3663703533bda6f5e1cd3dc4c", "warmup_time": -1}, "bench_ufunc.Custom.time_nonzero": {"code": "class Custom:\n    def time_nonzero(self):\n        np.nonzero(self.b)\n\n    def setup(self):\n        self.b = np.ones(20000, dtype=bool)\n        self.b_small = np.ones(3, dtype=bool)", "min_run_count": 2, "name": "bench_ufunc.Custom.time_nonzero", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "07cb8efc5305623785e369d9371f331170cc2b1a2e4c64b42a3ce8d964fdbb05", "warmup_time": -1}, "bench_ufunc.Custom.time_not_bool": {"code": "class Custom:\n    def time_not_bool(self):\n        (~self.b)\n\n    def setup(self):\n        self.b = np.ones(20000, dtype=bool)\n        self.b_small = np.ones(3, dtype=bool)", "min_run_count": 2, "name": "bench_ufunc.Custom.time_not_bool", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "49fb4bbdc82896a0b91d395ad6c09671344e60b648d9bd3ccb8f7c27001d4e95", "warmup_time": -1}, "bench_ufunc.Custom.time_or_bool": {"code": "class Custom:\n    def time_or_bool(self):\n        (self.b | self.b)\n\n    def setup(self):\n        self.b = np.ones(20000, dtype=bool)\n        self.b_small = np.ones(3, dtype=bool)", "min_run_count": 2, "name": "bench_ufunc.Custom.time_or_bool", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "12f2f069eef8ec94761a9a428fbc8537310f6b5522c6dc6b9d301b922b59a6f3", "warmup_time": -1}, "bench_ufunc.CustomArrayFloorDivideInt.time_floor_divide_int": {"code": "class CustomArrayFloorDivideInt:\n    def time_floor_divide_int(self, dtype, size):\n        self.x // self.y\n\n    def setup(self, dtype, size):\n        iinfo = np.iinfo(dtype)\n        self.x = np.random.randint(\n                    iinfo.min, iinfo.max, size=size, dtype=dtype)\n        self.y = np.random.randint(2, 32, size=size, dtype=dtype)", "min_run_count": 2, "name": "bench_ufunc.CustomArrayFloorDivideInt.time_floor_divide_int", "number": 0, "param_names": ["dtype", "size"], "params": [["<class 'numpy.int8'>", "<class 'numpy.int16'>", "<class 'numpy.int32'>", "<class 'numpy.int64'>", "<class 'numpy.uint8'>", "<class 'numpy.uint16'>", "<class 'numpy.uint32'>", "<class 'numpy.uint64'>"], ["100", "10000", "1000000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "836d1185a76698baeddf08d14dbada1257ce99342869af33a6d3dc7f8ca49b4c", "warmup_time": -1}, "bench_ufunc.CustomComparison.time_less_than_binary": {"code": "class CustomComparison:\n    def time_less_than_binary(self, dtype):\n        (self.x < self.y)\n\n    def setup(self, dtype):\n        self.x = np.ones(50000, dtype=dtype)\n        self.y = np.ones(50000, dtype=dtype)\n        self.s = np.ones(1, dtype=dtype)", "min_run_count": 2, "name": "bench_ufunc.CustomComparison.time_less_than_binary", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.int8'>", "<class 'numpy.int16'>", "<class 'numpy.int32'>", "<class 'numpy.int64'>", "<class 'numpy.uint8'>", "<class 'numpy.uint16'>", "<class 'numpy.uint32'>", "<class 'numpy.uint64'>", "<class 'numpy.float32'>", "<class 'numpy.float64'>", "<class 'numpy.bool_'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "703942b0d53a678d13fd5db6c8b411a5f543c7bf4e80716e3d5b49687e0de383", "warmup_time": -1}, "bench_ufunc.CustomComparison.time_less_than_scalar1": {"code": "class CustomComparison:\n    def time_less_than_scalar1(self, dtype):\n        (self.s < self.x)\n\n    def setup(self, dtype):\n        self.x = np.ones(50000, dtype=dtype)\n        self.y = np.ones(50000, dtype=dtype)\n        self.s = np.ones(1, dtype=dtype)", "min_run_count": 2, "name": "bench_ufunc.CustomComparison.time_less_than_scalar1", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.int8'>", "<class 'numpy.int16'>", "<class 'numpy.int32'>", "<class 'numpy.int64'>", "<class 'numpy.uint8'>", "<class 'numpy.uint16'>", "<class 'numpy.uint32'>", "<class 'numpy.uint64'>", "<class 'numpy.float32'>", "<class 'numpy.float64'>", "<class 'numpy.bool_'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b34519936803f8f3ce1360ac5246df4a6ab446f10319be953c16c1c998b8b3e1", "warmup_time": -1}, "bench_ufunc.CustomComparison.time_less_than_scalar2": {"code": "class CustomComparison:\n    def time_less_than_scalar2(self, dtype):\n        (self.x < self.s)\n\n    def setup(self, dtype):\n        self.x = np.ones(50000, dtype=dtype)\n        self.y = np.ones(50000, dtype=dtype)\n        self.s = np.ones(1, dtype=dtype)", "min_run_count": 2, "name": "bench_ufunc.CustomComparison.time_less_than_scalar2", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.int8'>", "<class 'numpy.int16'>", "<class 'numpy.int32'>", "<class 'numpy.int64'>", "<class 'numpy.uint8'>", "<class 'numpy.uint16'>", "<class 'numpy.uint32'>", "<class 'numpy.uint64'>", "<class 'numpy.float32'>", "<class 'numpy.float64'>", "<class 'numpy.bool_'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b477a1e8d7049309d120b63156fcf55f1a5f6794fc4faa3e94906c58a24d76b8", "warmup_time": -1}, "bench_ufunc.CustomInplace.time_char_or": {"code": "class CustomInplace:\n    def time_char_or(self):\n        np.bitwise_or(self.c, 0, out=self.c)\n        np.bitwise_or(0, self.c, out=self.c)\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.", "min_run_count": 2, "name": "bench_ufunc.CustomInplace.time_char_or", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e17e62b7756bffe100ff86408f24dcfb06a25b928f488c08f96ef0db5607f861", "warmup_time": -1}, "bench_ufunc.CustomInplace.time_char_or_temp": {"code": "class CustomInplace:\n    def time_char_or_temp(self):\n        0 | self.c | 0\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.", "min_run_count": 2, "name": "bench_ufunc.CustomInplace.time_char_or_temp", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1be81c7b7584c25261a4190fbfcf024b7b724516f69cad112327ad0d40e5476e", "warmup_time": -1}, "bench_ufunc.CustomInplace.time_double_add": {"code": "class CustomInplace:\n    def time_double_add(self):\n        np.add(self.d, 1., out=self.d)\n        np.add(1., self.d, out=self.d)\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.", "min_run_count": 2, "name": "bench_ufunc.CustomInplace.time_double_add", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f19662f4a311fc929de94204a4b67241b1bb5ccf947f71bac733c613ee769865", "warmup_time": -1}, "bench_ufunc.CustomInplace.time_double_add_temp": {"code": "class CustomInplace:\n    def time_double_add_temp(self):\n        1. + self.d + 1.\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.", "min_run_count": 2, "name": "bench_ufunc.CustomInplace.time_double_add_temp", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1e74700f4180455a4703910e2f5c4fda2ebd6ee1401a18d1a1ca8f093f3710e3", "warmup_time": -1}, "bench_ufunc.CustomInplace.time_float_add": {"code": "class CustomInplace:\n    def time_float_add(self):\n        np.add(self.f, 1., out=self.f)\n        np.add(1., self.f, out=self.f)\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.", "min_run_count": 2, "name": "bench_ufunc.CustomInplace.time_float_add", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "b11f548bdfbecba94fc50571119e32ffe7d6d2bbab330966d2acd80a91550b51", "warmup_time": -1}, "bench_ufunc.CustomInplace.time_float_add_temp": {"code": "class CustomInplace:\n    def time_float_add_temp(self):\n        1. + self.f + 1.\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.", "min_run_count": 2, "name": "bench_ufunc.CustomInplace.time_float_add_temp", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "715b0deebbb271f4d643d0575a3b913ed3729b2562da829c102f64b902f3de4d", "warmup_time": -1}, "bench_ufunc.CustomInplace.time_int_or": {"code": "class CustomInplace:\n    def time_int_or(self):\n        np.bitwise_or(self.i, 0, out=self.i)\n        np.bitwise_or(0, self.i, out=self.i)\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.", "min_run_count": 2, "name": "bench_ufunc.CustomInplace.time_int_or", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1e6eb0dc45e0d0d9a3dddce986d8940c73e4771e5e80bebc25eef75022122950", "warmup_time": -1}, "bench_ufunc.CustomInplace.time_int_or_temp": {"code": "class CustomInplace:\n    def time_int_or_temp(self):\n        0 | self.i | 0\n\n    def setup(self):\n        self.c = np.ones(500000, dtype=np.int8)\n        self.i = np.ones(150000, dtype=np.int32)\n        self.f = np.zeros(150000, dtype=np.float32)\n        self.d = np.zeros(75000, dtype=np.float64)\n        # fault memory\n        self.f *= 1.\n        self.d *= 1.", "min_run_count": 2, "name": "bench_ufunc.CustomInplace.time_int_or_temp", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "8892315dfcc7e6bf5be252fc352286cca4e2b317312e17686096539d1ca30496", "warmup_time": -1}, "bench_ufunc.CustomScalar.time_add_scalar2": {"code": "class CustomScalar:\n    def time_add_scalar2(self, dtype):\n        np.add(self.d, 1)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)", "min_run_count": 2, "name": "bench_ufunc.CustomScalar.time_add_scalar2", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "6c5ed02e001dd9bafa33d7f7b38ceb98abf8cdf8467193e7c0f53f94cf1bbc81", "warmup_time": -1}, "bench_ufunc.CustomScalar.time_divide_scalar2": {"code": "class CustomScalar:\n    def time_divide_scalar2(self, dtype):\n        np.divide(self.d, 1)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)", "min_run_count": 2, "name": "bench_ufunc.CustomScalar.time_divide_scalar2", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c32304caa2530a08b1034bd1ca4e575a5b9349681d9dde77b5994b93d5898994", "warmup_time": -1}, "bench_ufunc.CustomScalar.time_divide_scalar2_inplace": {"code": "class CustomScalar:\n    def time_divide_scalar2_inplace(self, dtype):\n        np.divide(self.d, 1, out=self.d)\n\n    def setup(self, dtype):\n        self.d = np.ones(20000, dtype=dtype)", "min_run_count": 2, "name": "bench_ufunc.CustomScalar.time_divide_scalar2_inplace", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "64e072c5d7cf47aa563db42bf4dea71a999c35f748b3f79a086af9c7cb266c92", "warmup_time": -1}, "bench_ufunc.CustomScalarFloorDivideInt.time_floor_divide_int": {"code": "class CustomScalarFloorDivideInt:\n    def time_floor_divide_int(self, dtype, divisor):\n        self.x // divisor\n\n    def setup(self, dtype, divisor):\n        if dtype in np.sctypes['uint'] and divisor < 0:\n            raise NotImplementedError(\n                    \"Skipping test for negative divisor with unsigned type\")\n    \n        iinfo = np.iinfo(dtype)\n        self.x = np.random.randint(\n                    iinfo.min, iinfo.max, size=10000, dtype=dtype)", "min_run_count": 2, "name": "bench_ufunc.CustomScalarFloorDivideInt.time_floor_divide_int", "number": 0, "param_names": ["dtype", "divisors"], "params": [["<class 'numpy.int8'>", "<class 'numpy.int16'>", "<class 'numpy.int32'>", "<class 'numpy.int64'>", "<class 'numpy.uint8'>", "<class 'numpy.uint16'>", "<class 'numpy.uint32'>", "<class 'numpy.uint64'>"], ["8", "-8", "43", "-43"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "4117e9cbb8ab1f8d3e10999fe2126e38f22fe26fc9ed7e2be2fd67824998d6eb", "warmup_time": -1}, "bench_ufunc.Scalar.time_add_scalar": {"code": "class Scalar:\n    def time_add_scalar(self):\n        (self.x + self.x)\n\n    def setup(self):\n        self.x = np.asarray(1.0)\n        self.y = np.asarray((1.0 + 1j))\n        self.z = complex(1.0, 1.0)", "min_run_count": 2, "name": "bench_ufunc.Scalar.time_add_scalar", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "eb95fd29e2ab6b42cbf524521b2f2318da4375c69e9eb9bd9367c5e2b2a30ea3", "warmup_time": -1}, "bench_ufunc.Scalar.time_add_scalar_conv": {"code": "class Scalar:\n    def time_add_scalar_conv(self):\n        (self.x + 1.0)\n\n    def setup(self):\n        self.x = np.asarray(1.0)\n        self.y = np.asarray((1.0 + 1j))\n        self.z = complex(1.0, 1.0)", "min_run_count": 2, "name": "bench_ufunc.Scalar.time_add_scalar_conv", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "bbf133739c730b558f163bfa0a41965f82312794363f18948bd93de0cdefc11a", "warmup_time": -1}, "bench_ufunc.Scalar.time_add_scalar_conv_complex": {"code": "class Scalar:\n    def time_add_scalar_conv_complex(self):\n        (self.y + self.z)\n\n    def setup(self):\n        self.x = np.asarray(1.0)\n        self.y = np.asarray((1.0 + 1j))\n        self.z = complex(1.0, 1.0)", "min_run_count": 2, "name": "bench_ufunc.Scalar.time_add_scalar_conv_complex", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ca23715a82f5300e9537e32b5a25944d9c56e195013449e49701a86f2600b87e", "warmup_time": -1}, "bench_ufunc.UFunc.time_ufunc_types": {"code": "class UFunc:\n    def time_ufunc_types(self, ufuncname):\n        [self.f(*arg) for arg in self.args]\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.args = []\n        for t, a in get_squares_().items():\n            arg = (a,) * self.f.nin\n            try:\n                self.f(*arg)\n            except TypeError:\n                continue\n            self.args.append(arg)", "min_run_count": 2, "name": "bench_ufunc.UFunc.time_ufunc_types", "number": 0, "param_names": ["ufunc"], "params": [["'abs'", "'absolute'", "'add'", "'arccos'", "'arccosh'", "'arcsin'", "'arcsinh'", "'arctan'", "'arctan2'", "'arctanh'", "'bitwise_and'", "'bitwise_not'", "'bitwise_or'", "'bitwise_xor'", "'cbrt'", "'ceil'", "'conj'", "'conjugate'", "'copysign'", "'cos'", "'cosh'", "'deg2rad'", "'degrees'", "'divide'", "'divmod'", "'equal'", "'exp'", "'exp2'", "'expm1'", "'fabs'", "'float_power'", "'floor'", "'floor_divide'", "'fmax'", "'fmin'", "'fmod'", "'frexp'", "'gcd'", "'greater'", "'greater_equal'", "'heaviside'", "'hypot'", "'invert'", "'isfinite'", "'isinf'", "'isnan'", "'isnat'", "'lcm'", "'ldexp'", "'left_shift'", "'less'", "'less_equal'", "'log'", "'log10'", "'log1p'", "'log2'", "'logaddexp'", "'logaddexp2'", "'logical_and'", "'logical_not'", "'logical_or'", "'logical_xor'", "'matmul'", "'maximum'", "'minimum'", "'mod'", "'modf'", "'multiply'", "'negative'", "'nextafter'", "'not_equal'", "'positive'", "'power'", "'rad2deg'", "'radians'", "'reciprocal'", "'remainder'", "'right_shift'", "'rint'", "'sign'", "'signbit'", "'sin'", "'sinh'", "'spacing'", "'sqrt'", "'square'", "'subtract'", "'tan'", "'tanh'", "'true_divide'", "'trunc'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "5e9a778c538969f78e1a50b387862004b9261c57231bd40e2b48ff4b647e46d8", "warmup_time": -1}, "bench_ufunc.UFuncSmall.time_ufunc_numpy_scalar": {"code": "class UFuncSmall:\n    def time_ufunc_numpy_scalar(self, ufuncname):\n        self.f(self.float64)\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.array_5 = np.array([1., 2., 10., 3., 4.])\n        self.array_int_3 = np.array([1, 2, 3])\n        self.float64 = np.float64(1.1)\n        self.python_float = 1.1", "min_run_count": 2, "name": "bench_ufunc.UFuncSmall.time_ufunc_numpy_scalar", "number": 0, "param_names": ["ufunc"], "params": [["'abs'", "'sqrt'", "'cos'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "045ce93fb7b0362836a4e8bead21ee109f1da838068ea13741758b58819df903", "warmup_time": -1}, "bench_ufunc.UFuncSmall.time_ufunc_python_float": {"code": "class UFuncSmall:\n    def time_ufunc_python_float(self, ufuncname):\n        self.f(self.python_float)\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.array_5 = np.array([1., 2., 10., 3., 4.])\n        self.array_int_3 = np.array([1, 2, 3])\n        self.float64 = np.float64(1.1)\n        self.python_float = 1.1", "min_run_count": 2, "name": "bench_ufunc.UFuncSmall.time_ufunc_python_float", "number": 0, "param_names": ["ufunc"], "params": [["'abs'", "'sqrt'", "'cos'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "b184e33e2b5d009739175c1990343abab0f6ae50194e84b9654f7e93db7f0e0f", "warmup_time": -1}, "bench_ufunc.UFuncSmall.time_ufunc_small_array": {"code": "class UFuncSmall:\n    def time_ufunc_small_array(self, ufuncname):\n        self.f(self.array_5)\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.array_5 = np.array([1., 2., 10., 3., 4.])\n        self.array_int_3 = np.array([1, 2, 3])\n        self.float64 = np.float64(1.1)\n        self.python_float = 1.1", "min_run_count": 2, "name": "bench_ufunc.UFuncSmall.time_ufunc_small_array", "number": 0, "param_names": ["ufunc"], "params": [["'abs'", "'sqrt'", "'cos'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "dafbcff34284d9303c172c16702609e8fd2fe02893343f15b9fca1fb6290806c", "warmup_time": -1}, "bench_ufunc.UFuncSmall.time_ufunc_small_array_inplace": {"code": "class UFuncSmall:\n    def time_ufunc_small_array_inplace(self, ufuncname):\n        self.f(self.array_5, out = self.array_5)\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.array_5 = np.array([1., 2., 10., 3., 4.])\n        self.array_int_3 = np.array([1, 2, 3])\n        self.float64 = np.float64(1.1)\n        self.python_float = 1.1", "min_run_count": 2, "name": "bench_ufunc.UFuncSmall.time_ufunc_small_array_inplace", "number": 0, "param_names": ["ufunc"], "params": [["'abs'", "'sqrt'", "'cos'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "024306da714126ce53d6ee606e1459f61671fd258eb9df2d60e211e8ed436404", "warmup_time": -1}, "bench_ufunc.UFuncSmall.time_ufunc_small_int_array": {"code": "class UFuncSmall:\n    def time_ufunc_small_int_array(self, ufuncname):\n        self.f(self.array_int_3)\n\n    def setup(self, ufuncname):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError()\n        self.array_5 = np.array([1., 2., 10., 3., 4.])\n        self.array_int_3 = np.array([1, 2, 3])\n        self.float64 = np.float64(1.1)\n        self.python_float = 1.1", "min_run_count": 2, "name": "bench_ufunc.UFuncSmall.time_ufunc_small_int_array", "number": 0, "param_names": ["ufunc"], "params": [["'abs'", "'sqrt'", "'cos'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "b101cc6f768a668e011b3d926f5f9de0e7fde26cf4d6596ee56509fcaf87819f", "warmup_time": -1}, "bench_ufunc_strides.AVX_UFunc_log.time_log": {"code": "class AVX_UFunc_log:\n    def time_log(self, stride, dtype):\n        np.log(self.arr[::stride])\n\n    def setup(self, stride, dtype):\n        np.seterr(all='ignore')\n        N = 10000\n        self.arr = np.array(np.random.random_sample(stride*N), dtype=dtype)", "min_run_count": 2, "name": "bench_ufunc_strides.AVX_UFunc_log.time_log", "number": 0, "param_names": ["stride", "dtype"], "params": [["1", "2", "4"], ["'e'", "'f'", "'d'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "758b2c2d627de74fb1523a7612f0bc5575388c40d22107bcee8e49ecb7cbbfd4", "warmup_time": -1}, "bench_ufunc_strides.AVX_cmplx_arithmetic.time_ufunc": {"code": "class AVX_cmplx_arithmetic:\n    def time_ufunc(self, bfuncname, stride, dtype):\n        self.f(self.arr1[::stride], self.arr2[::stride])\n\n    def setup(self, bfuncname, stride, dtype):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, bfuncname)\n        except AttributeError:\n            raise NotImplementedError(f\"No bfunc {bfuncname} found\") from None\n        N = 10000\n        self.arr1 = np.ones(stride*N, dtype)\n        self.arr2 = np.ones(stride*N, dtype)", "min_run_count": 2, "name": "bench_ufunc_strides.AVX_cmplx_arithmetic.time_ufunc", "number": 0, "param_names": ["bfunc", "stride", "dtype"], "params": [["'add'", "'subtract'", "'multiply'", "'divide'"], ["1", "2", "4"], ["'F'", "'D'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "6d182e83551b08781041f2192c70fd0ed7cafbb3bd3492a45cc7064da1b49319", "warmup_time": -1}, "bench_ufunc_strides.AVX_cmplx_funcs.time_ufunc": {"code": "class AVX_cmplx_funcs:\n    def time_ufunc(self, bfuncname, stride, dtype):\n        self.f(self.arr1[::stride])\n\n    def setup(self, bfuncname, stride, dtype):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, bfuncname)\n        except AttributeError:\n            raise NotImplementedError(f\"No bfunc {bfuncname} found\") from None\n        N = 10000\n        self.arr1 = np.ones(stride*N, dtype)", "min_run_count": 2, "name": "bench_ufunc_strides.AVX_cmplx_funcs.time_ufunc", "number": 0, "param_names": ["bfunc", "stride", "dtype"], "params": [["'reciprocal'", "'absolute'", "'square'", "'conjugate'"], ["1", "2", "4"], ["'F'", "'D'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "c512db7e180ac3a2a2b566dc24527d74e5cbf2afe29b1f3bee89b00127ee699b", "warmup_time": -1}, "bench_ufunc_strides.AVX_ldexp.time_ufunc": {"code": "class AVX_ldexp:\n    def time_ufunc(self, dtype, stride):\n        self.f(self.arr1[::stride], self.arr2[::stride])\n\n    def setup(self, dtype, stride):\n        np.seterr(all='ignore')\n        self.f = getattr(np, 'ldexp')\n        N = 10000\n        self.arr1 = np.array(np.random.rand(stride*N), dtype=dtype)\n        self.arr2 = np.array(np.random.rand(stride*N), dtype='i')", "min_run_count": 2, "name": "bench_ufunc_strides.AVX_ldexp.time_ufunc", "number": 0, "param_names": ["dtype", "stride"], "params": [["'e'", "'f'", "'d'"], ["1", "2", "4"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "7b1485348542d48680da2c54ca6f3126661e7a3df7bc726f193d3961f6708ebe", "warmup_time": -1}, "bench_ufunc_strides.Binary.time_ufunc": {"code": "class Binary:\n    def time_ufunc(self, ufuncname, stride_in0, stride_in1, stride_out, dtype):\n        self.f(self.arr1[::stride_in0], self.arr2[::stride_in1],\n               self.arr_out[::stride_out])\n\n    def setup(self, ufuncname, stride_in0, stride_in1, stride_out, dtype):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError(f\"No ufunc {ufuncname} found\") from None\n        N = 100000\n        self.arr1 = np.array(np.random.rand(stride_in0*N), dtype=dtype)\n        self.arr2 = np.array(np.random.rand(stride_in1*N), dtype=dtype)\n        self.arr_out = np.empty(stride_out*N, dtype)", "min_run_count": 2, "name": "bench_ufunc_strides.Binary.time_ufunc", "number": 0, "param_names": ["ufunc", "stride_in0", "stride_in1", "stride_out", "dtype"], "params": [["'maximum'", "'minimum'", "'fmax'", "'fmin'"], ["1", "2", "4"], ["1", "2", "4"], ["1", "2", "4"], ["'f'", "'d'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "a9e6a1fbda7b38a42e8a0945997c932755d443c026f20c83105618342c0d8836", "warmup_time": -1}, "bench_ufunc_strides.BinaryInt.time_ufunc": {"code": "class Binary:\n    def time_ufunc(self, ufuncname, stride_in0, stride_in1, stride_out, dtype):\n        self.f(self.arr1[::stride_in0], self.arr2[::stride_in1],\n               self.arr_out[::stride_out])\n\n    def setup(self, ufuncname, stride_in0, stride_in1, stride_out, dtype):\n        np.seterr(all='ignore')\n        try:\n            self.f = getattr(np, ufuncname)\n        except AttributeError:\n            raise NotImplementedError(f\"No ufunc {ufuncname} found\") from None\n        N = 100000\n        self.arr1 = np.array(np.random.rand(stride_in0*N), dtype=dtype)\n        self.arr2 = np.array(np.random.rand(stride_in1*N), dtype=dtype)\n        self.arr_out = np.empty(stride_out*N, dtype)", "min_run_count": 2, "name": "bench_ufunc_strides.BinaryInt.time_ufunc", "number": 0, "param_names": ["ufunc", "stride_in0", "stride_in1", "stride_out", "dtype"], "params": [["'maximum'", "'minimum'"], ["1", "2", "4"], ["1", "2", "4"], ["1", "2", "4"], ["'b'", "'B'", "'h'", "'H'", "'i'", "'I'", "'l'", "'L'", "'q'", "'Q'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "a9e6a1fbda7b38a42e8a0945997c932755d443c026f20c83105618342c0d8836", "warmup_time": -1}, "bench_ufunc_strides.LogisticRegression.time_train": {"code": "class LogisticRegression:\n    def time_train(self, dtype):\n        self.train(1000)\n\n    def setup(self, dtype):\n        np.random.seed(42)\n        self.size = 250\n        features = 16\n        self.X_train = np.random.rand(self.size,features).astype(dtype)\n        self.Y_train = np.random.choice(2,self.size).astype(dtype)\n        # Initialize weights\n        self.W = np.zeros((features,1), dtype=dtype)\n        self.b = np.zeros((1,1), dtype=dtype)\n        self.alpha = 0.1", "min_run_count": 2, "name": "bench_ufunc_strides.LogisticRegression.time_train", "number": 0, "param_names": ["dtype"], "params": [["<class 'numpy.float32'>", "<class 'numpy.float64'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 1000, "type": "time", "unit": "seconds", "version": "e86e16eb2784715dd92cc28fe3cf3d4b7cd03bbfb23570674abc1d06d35e8505", "warmup_time": -1}, "bench_ufunc_strides.Mandelbrot.time_mandel": {"code": "class Mandelbrot:\n    def time_mandel(self):\n        self.mandelbrot_set(-0.74877,-0.74872,0.06505,0.06510,1000,1000,2048)", "min_run_count": 2, "name": "bench_ufunc_strides.Mandelbrot.time_mandel", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "74f62bffab8b9720277f099c1fb8d06c8eb635599e335a58345cf121cd5a7b59", "warmup_time": -1}, "bench_ufunc_strides.Unary.time_ufunc": {"code": "class Unary:\n    def time_ufunc(self, ufuncname, stride, stride_out, dtype):\n        self.f(self.arr[::stride], self.arr_out[::stride_out])\n\n    def setup(self, ufuncname, stride, stride_out, dtype):\n        np.seterr(all='ignore')\n        try:\n            self.f = ufuncname\n        except AttributeError:\n            raise NotImplementedError(f\"No ufunc {ufuncname} found\") from None\n        N = 100000\n        self.arr_out = np.empty(stride_out*N, dtype)\n        self.arr = np.random.rand(stride*N).astype(dtype)\n        if (ufuncname.__name__ == 'arccosh'):\n            self.arr = 1.0 + self.arr", "min_run_count": 2, "name": "bench_ufunc_strides.Unary.time_ufunc", "number": 0, "param_names": ["ufunc", "stride_in", "stride_out", "dtype"], "params": [["<ufunc 'absolute'>", "<ufunc 'arccos'>", "<ufunc 'arccosh'>", "<ufunc 'arcsin'>", "<ufunc 'arcsinh'>", "<ufunc 'arctan'>", "<ufunc 'arctanh'>", "<ufunc 'cbrt'>", "<ufunc 'ceil'>", "<ufunc 'conjugate'> (0)", "<ufunc 'cos'>", "<ufunc 'cosh'>", "<ufunc 'deg2rad'>", "<ufunc 'degrees'>", "<ufunc 'exp'>", "<ufunc 'exp2'>", "<ufunc 'expm1'>", "<ufunc 'fabs'>", "<ufunc 'floor'>", "<ufunc 'log'>", "<ufunc 'log10'>", "<ufunc 'log1p'>", "<ufunc 'log2'>", "<ufunc 'logical_not'>", "<ufunc 'negative'>", "<ufunc 'positive'>", "<ufunc 'rad2deg'>", "<ufunc 'radians'>", "<ufunc 'reciprocal'>", "<ufunc 'rint'>", "<ufunc 'sign'>", "<ufunc 'sin'>", "<ufunc 'sinh'>", "<ufunc 'sqrt'>", "<ufunc 'square'>", "<ufunc 'tan'>", "<ufunc 'tanh'>", "<ufunc 'trunc'>", "<ufunc 'conjugate'> (1)", "<ufunc '_ones_like'>"], ["1", "2", "4"], ["1", "2", "4"], ["'e'", "'f'", "'d'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "timeout": 10, "type": "time", "unit": "seconds", "version": "bafb7199f7f833abd6676b607042ae3191aedad2b0adbe2dd293b742a9fe5222", "warmup_time": -1}}, "machines": {"rurgi9home": {"arch": "x86_64", "cpu": "11th Gen Intel(R) Core(TM) i9-11900K @ 3.50GHz", "machine": "rurgi9home", "num_cpu": "16", "os": "Linux 6.1.1-arch1-1", "ram": "65592908", "version": 1}}, "tags": {"enable_separate_by_default": 10683, "pre-removal-numpybook": 13148, "v0.2.0": 42, "v0.2.2": 740, "v0.3.0": 760, "v0.3.2": 871, "v0.4.2b1": 1215, "v0.6.0": 1435, "v0.6.1": 1441, "v0.8.4": 1591, "v0.9.2": 1767, "v0.9.4": 1916, "v0.9.5": 2054, "v0.9.6": 2167, "v0.9.8": 2472, "v1.0": 3290, "v1.0.1": 3366, "v1.0.2": 3543, "v1.0.3": 3724, "v1.0.3.1": 3846, "v1.0.4": 3983, "v1.0b1": 2788, "v1.0b2": 2916, "v1.0b3": 2949, "v1.0b4": 2986, "v1.0b5": 3015, "v1.0rc1": 3096, "v1.0rc2": 3192, "v1.0rc3": 3259, "v1.1.0": 4635, "v1.1.0rc1": 4589, "v1.1.1": 4948, "v1.1.1rc1": 4881, "v1.1.1rc2": 4904, "v1.10.0": 15429, "v1.10.0.post2": 15442, "v1.10.0b1": 15167, "v1.10.0rc2": 15380, "v1.10.1": 15495, "v1.10.2": 15898, "v1.10.2rc1": 15747, "v1.10.2rc2": 15860, "v1.10.3": 16072, "v1.10.4": 16076, "v1.11.0": 16687, "v1.11.0b1": 16292, "v1.11.0b2": 16308, "v1.11.0b3": 16415, "v1.11.0rc1": 16528, "v1.11.0rc2": 16649, "v1.11.1": 16985, "v1.11.1rc1": 16881, "v1.11.2": 17276, "v1.11.2rc1": 17223, "v1.11.3": 17559, "v1.12.0": 17657, "v1.12.0b1": 17442, "v1.12.0rc1": 17583, "v1.12.0rc2": 17616, "v1.12.1": 17999, "v1.12.1rc1": 17963, "v1.13.0": 18529, "v1.13.0rc1": 18416, "v1.13.0rc2": 18468, "v1.13.1": 18680, "v1.13.2": 19123, "v1.13.3": 19142, "v1.14.0": 19766, "v1.14.0rc1": 19604, "v1.14.1": 20042, "v1.14.2": 20126, "v1.14.3": 20435, "v1.14.4": 20710, "v1.14.5": 20777, "v1.14.6": 21564, "v1.15.0": 21087, "v1.15.0rc1": 20876, "v1.15.0rc2": 21025, "v1.15.1": 21301, "v1.15.2": 21555, "v1.15.3": 21852, "v1.15.4": 21951, "v1.16.0": 22436, "v1.16.0rc1": 22287, "v1.16.0rc2": 22366, "v1.16.1": 22608, "v1.16.2": 22727, "v1.16.3": 23110, "v1.16.4": 23538, "v1.16.5": 24465, "v1.16.6": 25425, "v1.17.0": 24160, "v1.17.0rc1": 23799, "v1.17.0rc2": 23987, "v1.17.1": 24433, "v1.17.2": 24549, "v1.17.3": 24911, "v1.17.4": 25109, "v1.17.5": 25436, "v1.18.0": 25381, "v1.18.0rc1": 25289, "v1.18.1": 25522, "v1.18.2": 26045, "v1.18.3": 26261, "v1.18.4": 26366, "v1.18.5": 26756, "v1.19.0": 26965, "v1.19.0rc1": 26517, "v1.19.0rc2": 26737, "v1.19.1": 27319, "v1.19.2": 27788, "v1.19.3": 28368, "v1.19.4": 28400, "v1.19.5": 29054, "v1.2.0": 5203, "v1.2.0b1": 4998, "v1.2.0b2": 5005, "v1.2.0rc1": 5090, "v1.2.0rc2": 5144, "v1.2.1": 5277, "v1.20.0": 29309, "v1.20.0rc1": 28712, "v1.20.0rc2": 28989, "v1.20.1": 29464, "v1.20.2": 29995, "v1.20.3": 30443, "v1.21.0": 31014, "v1.21.0.dev0": 28643, "v1.21.0rc1": 30659, "v1.21.0rc2": 30843, "v1.21.1": 31377, "v1.21.2": 31663, "v1.21.3": 32305, "v1.21.4": 32553, "v1.21.5": 33091, "v1.21.6": 34037, "v1.22.0": 33175, "v1.22.0.dev0": 30637, "v1.22.0rc1": 32782, "v1.22.0rc2": 32963, "v1.22.0rc3": 33084, "v1.22.1": 33336, "v1.22.2": 33643, "v1.22.3": 33867, "v1.22.4": 34278, "v1.23.0": 34793, "v1.23.0.dev0": 32698, "v1.23.0rc1": 34392, "v1.23.0rc2": 34431, "v1.23.0rc3": 34604, "v1.23.1": 34954, "v1.23.2": 35133, "v1.23.3": 35273, "v1.23.4": 35477, "v1.23.5": 35790, "v1.24.0": 36101, "v1.24.0.dev0": 34320, "v1.24.0rc1": 35844, "v1.24.0rc2": 35980, "v1.25.0.dev0": 35819, "v1.3.0": 6111, "v1.3.0b1": 5964, "v1.3.0rc1": 6082, "v1.3.0rc2": 6105, "v1.4.0": 7290, "v1.4.0rc1": 7077, "v1.4.0rc2": 7287, "v1.4.1": 7607, "v1.4.1rc1": 7596, "v1.4.1rc2": 7601, "v1.4.1rc3": 7605, "v1.5.0": 7924, "v1.5.0b1": 7838, "v1.5.0b2": 7900, "v1.5.0rc1": 7919, "v1.5.1": 8094, "v1.5.1rc1": 8049, "v1.5.1rc2": 8077, "v1.6.0": 8765, "v1.6.0b1": 8515, "v1.6.0b2": 8649, "v1.6.0rc1": 8733, "v1.6.0rc2": 8748, "v1.6.0rc3": 8759, "v1.6.1": 9071, "v1.6.1rc1": 8847, "v1.6.1rc2": 8956, "v1.6.1rc3": 9026, "v1.6.2": 9876, "v1.6.2rc1": 9830, "v1.7.0": 10714, "v1.7.0b1": 10100, "v1.7.0b2": 10201, "v1.7.0rc1": 10586, "v1.7.0rc2": 10713, "v1.7.1": 10952, "v1.7.1rc1": 10894, "v1.7.2": 12590, "v1.7.2rc1": 12438, "v1.8.0": 12411, "v1.8.0b1": 11907, "v1.8.0b2": 11963, "v1.8.0rc1": 12166, "v1.8.0rc2": 12280, "v1.8.1": 13266, "v1.8.1rc1": 13048, "v1.8.2": 13799, "v1.8.2rc1": 13794, "v1.9.0": 13918, "v1.9.0b1": 13574, "v1.9.0b2": 13746, "v1.9.0rc1": 13857, "v1.9.1": 14153, "v1.9.1rc1": 14134, "v1.9.2": 14555, "v1.9.2rc1": 14443, "v1.9.3": 15308, "with_maskna": 9952}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}